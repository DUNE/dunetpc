////////////////////////////////////////////////////////////////////////
// Class:       HadCal
// Module Type: analyzer
// File:        HadCal_module.cc
//
// Generated at Wed Feb  8 09:38:58 2017 by Dorota Stefan using artmod
// from cetpkgsupport v1_11_00.
////////////////////////////////////////////////////////////////////////

#include "lardataobj/Simulation/SimChannel.h"
#include "larsim/Simulation/LArG4Parameters.h"
#include "larsim/Simulation/LArVoxelData.h"
#include "larsim/Simulation/LArVoxelList.h"
#include "larsim/Simulation/SimListUtils.h"
#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/GeometryCore.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "larreco/Calorimetry/CalorimetryAlg.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "larcoreobj/SimpleTypesAndConstants/PhysicalConstants.h"
#include "lardata/Utilities/DatabaseUtil.h"

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "lardata/ArtDataHelper/MVAReader.h"

#include "TH1.h"
#include "TTree.h"
#include "TLorentzVector.h"
#include "TVector3.h"

#define MVA_LENGTH 3

namespace proto
{
	class HadCal;
}

class proto::HadCal : public art::EDAnalyzer {
public:
  explicit HadCal(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  HadCal(HadCal const &) = delete;
  HadCal(HadCal &&) = delete;
  HadCal & operator = (HadCal const &) = delete;
  HadCal & operator = (HadCal &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  
  void beginJob() override;

	void reconfigure(fhicl::ParameterSet const& p) override;

private:

  // Declare member data here.
  
  TTree *fTree;
  int fRun;
  int fEvent;
  int fBestView;
  int fNumberOfTracks;
  double fHadEnSum;
  
  void ResetVars();
  
  // Module labels to get data products
  anab::Calorimetry fCalorimetry;
  art::InputTag fNNetModuleLabel;
  std::string fTrackModuleLabel;
  std::string fCalorimetryModuleLabel;
};


proto::HadCal::HadCal(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)
 // More initializers here.
{
	reconfigure(p);
}

void proto::HadCal::beginJob()
{
	// access art's TFileService, which will handle creating and writing hists
	art::ServiceHandle<art::TFileService> tfs;	
	
	fTree = tfs->make<TTree>("calibration","calibration tree");
	fTree->Branch("fRun", &fRun, "fRun/I");
	fTree->Branch("fEvent", &fEvent, "fEvent/I");
	fTree->Branch("fNumberOfTracks", &fNumberOfTracks, "fNumberOfTracks/I");
	fTree->Branch("fHadEnSum", &fHadEnSum, "fHadEnSum/D");
}

void proto::HadCal::reconfigure(fhicl::ParameterSet const & p)
{
	fTrackModuleLabel = p.get< std::string >("TrackModuleLabel");
	fCalorimetryModuleLabel = p.get< std::string >("CalorimetryModuleLabel");
	fNNetModuleLabel = p.get< std::string >("NNetModuleLabel");
}

void proto::HadCal::analyze(art::Event const & e)
{
  // Implementation of required member function here.
  ResetVars();
  
  fRun = e.run();
  fEvent = e.id().event();
  double ekin = 0.0;
  
  // output from cnn's
  auto trkResults = anab::MVAReader< recob::Track, MVA_LENGTH>::create(e, fNNetModuleLabel);
  
    
  if (trkResults)
  {
  	fNumberOfTracks = trkResults->size();
  
  	// use handle and input tag of reco objects associated to cnn output
  	const art::FindManyP< anab::Calorimetry > calFromTracks(trkResults->dataHandle(), e, fCalorimetryModuleLabel);	
  	
  	for (size_t t = 0; t < trkResults->size(); ++t)
  	{
  		int nplanes = calFromTracks.at(t).size(); 	
  
  		std::array< float, MVA_LENGTH > cnn_out = trkResults->getOutput(t); 
  		
  		if ( (cnn_out[1] / (cnn_out[0] + cnn_out[1])) >= 0.63)
  		{
  			if (nplanes == 3)
  			{
  				if (calFromTracks.at(t)[2]->KineticEnergy() > 0)
  				{
  					ekin = calFromTracks.at(t)[2]->KineticEnergy();
  				} 
  				else if (calFromTracks.at(t)[1]->KineticEnergy() > 0)
  				{
  					ekin = calFromTracks.at(t)[1]->KineticEnergy();
  				}
 					else if (calFromTracks.at(t)[0]->KineticEnergy() > 0)
 					{
 						ekin = calFromTracks.at(t)[0]->KineticEnergy();
  				}
  				else
  				{
  					ekin = 0.0;
  				}
  			}
  			else if (nplanes == 2)
 				{
  				if (calFromTracks.at(t)[1]->KineticEnergy() > 0)
  				{
  					ekin = calFromTracks.at(t)[1]->KineticEnergy();
  				}
  				else if (calFromTracks.at(t)[0]->KineticEnergy() > 0)
  				{
  					ekin = calFromTracks.at(t)[0]->KineticEnergy();
  				}
  				else
  				{
  					ekin = 0.0;
 					}
 				}
 				else
  			{
  				ekin = 0.0;
  			}
  					
  			fHadEnSum += ekin;
  			
  		}
  	}
  	
  }
}


void proto::HadCal::ResetVars()
{
	fRun = 0;
	fEvent = 0;
	fBestView = 2;
	fNumberOfTracks = 0;
  fHadEnSum = 0;
}

DEFINE_ART_MODULE(proto::HadCal)
