////////////////////////////////////////////////////////////////////////
// Class:       HadCal
// Module Type: analyzer
// File:        HadCal_module.cc
//
// Generated at Wed Feb  8 09:38:58 2017 by Dorota Stefan using artmod
// from cetpkgsupport v1_11_00.
////////////////////////////////////////////////////////////////////////

#include "lardataobj/Simulation/SimChannel.h"
#include "larsim/Simulation/LArG4Parameters.h"
#include "larsim/Simulation/LArVoxelData.h"
#include "larsim/Simulation/LArVoxelList.h"
#include "larsim/Simulation/SimListUtils.h"
#include "larcore/Geometry/Geometry.h"
#include "larcore/Geometry/GeometryCore.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardataobj/RecoBase/Cluster.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/AnalysisBase/Calorimetry.h"
#include "larreco/Calorimetry/CalorimetryAlg.h"
#include "nusimdata/SimulationBase/MCParticle.h"
#include "nusimdata/SimulationBase/MCTruth.h"
#include "larcoreobj/SimpleTypesAndConstants/PhysicalConstants.h"
#include "lardata/Utilities/DatabaseUtil.h"

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "canvas/Persistency/Common/FindManyP.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "lardata/ArtDataHelper/MVAReader.h"

#include "TH1.h"
#include "TTree.h"
#include "TLorentzVector.h"
#include "TVector3.h"

#define MVA_LENGTH 3

namespace proto
{
	class HadCal;
}

class proto::HadCal : public art::EDAnalyzer {
public:
  explicit HadCal(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  HadCal(HadCal const &) = delete;
  HadCal(HadCal &&) = delete;
  HadCal & operator = (HadCal const &) = delete;
  HadCal & operator = (HadCal &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;
  
  void beginJob() override;

	void reconfigure(fhicl::ParameterSet const& p) override;

private:

  // Declare member data here.
  
  TTree *fTree;
  int fRun;
  int fEvent;
  int fBestView;
  int fNumberOfTracks;
  double fHadEnSum;
  
  void ResetVars();
  double KinEn(recob::Track const & tack);
  
  // Module labels to get data products
  anab::Calorimetry fCalorimetry;
  art::InputTag fNNetModuleLabel;
  std::string fTrackModuleLabel;
  std::string fCalorimetryModuleLabel;
};


proto::HadCal::HadCal(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)
 // More initializers here.
{
	reconfigure(p);
}

void proto::HadCal::beginJob()
{
	// access art's TFileService, which will handle creating and writing hists
	art::ServiceHandle<art::TFileService> tfs;	
	
	fTree = tfs->make<TTree>("calibration","calibration tree");
	fTree->Branch("fRun", &fRun, "fRun/I");
	fTree->Branch("fEvent", &fEvent, "fEvent/I");
	fTree->Branch("fNumberOfTracks", &fNumberOfTracks, "fNumberOfTracks/I");
	fTree->Branch("fHadEnSum", &fHadEnSum, "fHadEnSum/D");
}

void proto::HadCal::reconfigure(fhicl::ParameterSet const & p)
{
	fTrackModuleLabel = p.get< std::string >("TrackModuleLabel");
	fCalorimetryModuleLabel = p.get< std::string >("CalorimetryModuleLabel");
	fNNetModuleLabel = p.get< std::string >("NNetModuleLabel");
}

void proto::HadCal::analyze(art::Event const & e)
{
  // Implementation of required member function here.
  ResetVars();
  
  fRun = e.run();
  fEvent = e.id().event();
  
  auto trkHandle = e.getValidHandle< std::vector<recob::Track> >(fTrackModuleLabel);
  const art::FindManyP< anab::Calorimetry > tracksFromCal(trkHandle, e, fCalorimetryModuleLabel);
  
  std::cout << " number of tracks: " << trkHandle->size() << std::endl;
  for (size_t t = 0; t < trkHandle->size(); ++t)
  {
  	std::cout << " length " << trkHandle->at(t).Length() << std::endl;
  	std::cout << " vec size: " << tracksFromCal.at(t).size() << std::endl;
  	std::cout << " kin en: " << std::endl;
  	for (size_t e = 0; e < tracksFromCal.at(t).size(); ++e)
  	{
  		std::cout << tracksFromCal.at(t)[e]->KineticEnergy() << std::endl;
  	}
  	
  }
  
  // output from cnn's
  
  auto trkResults = anab::MVAReader< recob::Track, MVA_LENGTH>::create(e, fNNetModuleLabel);
  if (trkResults)
  {
  	
  	
  	for (size_t t = 0; t < trkResults->size(); ++t)
  	{
  		const recob::Track & trk = trkResults->item(t);
  		fHadEnSum += KinEn(trk);
  		// std::array< float, MVA_LENGTH > cnn_out = trkResults->getOutput(t);
  	}
  	
  	fNumberOfTracks = trkResults->size();
  }
  
}

double proto::HadCal::KinEn(recob::Track const & track)
{
	double ekin = 0.0;
	
	
	
	
	return ekin;
}


void proto::HadCal::ResetVars()
{
	fRun = 0;
	fEvent = 0;
	fBestView = 2;
	fNumberOfTracks = 0;
  fHadEnSum = 0;
}

DEFINE_ART_MODULE(proto::HadCal)
