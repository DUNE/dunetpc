// art includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "art/Framework/Services/Optional/TFileService.h"

// artdaq and dune-raw-data includes
#include "dune-raw-data/Overlays/RceFragment.hh"
#include "artdaq-core/Data/Fragment.hh"
#include "artdaq-core/Data/ContainerFragment.hh"
#include "dune-raw-data/Overlays/FragmentType.hh"
#include "dune-raw-data/Services/ChannelMap/PdChannelMapService.h"

// larsoft includes
#include "lardataobj/RawData/RawDigit.h"

// ROOT includes
#include "TH1.h"

// C++ Includes
#include <memory>
#include <iostream>

namespace dune {
  class RceRawDecoder;
}

class dune::RceRawDecoder : public art::EDProducer {
public:
  explicit RceRawDecoder(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  RceRawDecoder(RceRawDecoder const &) = delete;
  RceRawDecoder(RceRawDecoder &&) = delete;
  RceRawDecoder & operator = (RceRawDecoder const &) = delete;
  RceRawDecoder & operator = (RceRawDecoder &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;
  void reconfigure(const fhicl::ParameterSet &pset);
  void beginJob();

  void setRootObjects();

private:
  typedef std::vector<raw::RawDigit> RawDigits;

  bool _process(
          const artdaq::Fragment& frag, 
          RawDigits& raw_digits);

  // Declare member data here.
  std::string _input_label; 
  std::string _output_label;
  bool _expect_container_fragments;

  TH1D* _h_nticks;
  TH1I * _h_all_adc_values;
  TH1I* _h_online_channels;
  TH1I* _h_offline_channels;
  std::vector<uint16_t> _buffer;
};


dune::RceRawDecoder::RceRawDecoder(fhicl::ParameterSet const & pset)
// :
// Initialize member data here.
{
  art::ServiceHandle<art::TFileService> fs;
  //fs->registerFileSwitchCallback(this, &RceRawDecoder::setRootObjects);
  setRootObjects();

  reconfigure(pset);
  // Call appropriate produces<>() functions here.
  //produces< std::vector<raw::RawDigit> > ( _output_label );  
  produces<RawDigits>( _output_label );  
}

void dune::RceRawDecoder::reconfigure(fhicl::ParameterSet const& pset) {

  _input_label = pset.get<std::string>("RawDataLabel");
  _output_label = pset.get<std::string>("OutputDataLabel");
  _expect_container_fragments = pset.get<bool>("ExpectContainerFragments", true);
}

void dune::RceRawDecoder::setRootObjects(){
  art::ServiceHandle<art::TFileService> file_srv;
  _h_nticks = file_srv->make<TH1D>("rce_NTicks","TPC: Number of ticks",  100, 0, 20000);
  _h_nticks->SetXTitle("NTicks");
  _h_all_adc_values = file_srv->make<TH1I>("rce_All_ADC_values","TPC: All_ADC_values",  5000, 0, 5000);
  _h_online_channels = file_srv->make<TH1I>("rce_Online_Channels", "TPC: Online Channel ID", 5000, 0, 5000);
  _h_offline_channels = file_srv->make<TH1I>("rce_Offline_Channels", "TPC: Offline Channel ID", 5000, 0, 5000);
}
void dune::RceRawDecoder::beginJob(){
}

void dune::RceRawDecoder::produce(art::Event & evt){
    // TODO Use LOG_DEBUG
    LOG_INFO("RceRawDecoder")
      << "-------------------- RCE RawDecoder -------------------";

  RawDigits raw_digits;
  unsigned int n_rce_frags = 0;

  if (_expect_container_fragments) {
    art::Handle<artdaq::Fragments> cont_frags;
    evt.getByLabel(_input_label, "ContainerTPC", cont_frags);
    art::EventNumber_t eventNumber = evt.event();
    // Check if there is Timing data in this event
    // Don't crash code if not present, just don't save anything
    try { cont_frags->size(); }
    catch(std::exception e) {
      std::cout << "WARNING: Container TPC/RCE data not found in event " << eventNumber << std::endl;
      std::vector<raw::RawDigit> digits;
      evt.put(std::make_unique<std::vector<raw::RawDigit>>(std::move(digits)), _output_label);
      return;
    }
    //Check that the data is valid
    if(!cont_frags.isValid()){
      LOG_ERROR("RceRawDecoder")
          << "Run: " << evt.run()
		  << ", SubRun: " << evt.subRun()
          << ", Event: " << evt.event()
		  << " Container Fragments is NOT VALID";
    }
    
    for (auto const& cont : *cont_frags)
    {
      artdaq::ContainerFragment cont_frag(cont);
      for (size_t ii = 0; ii < cont_frag.block_count(); ++ii)
	{
	  artdaq::Fragment frag;
          size_t frag_size = cont_frag.fragSize(ii);
	  frag.resizeBytes(frag_size);

	  memcpy(frag.headerAddress(), cont_frag.at(ii), frag_size);
          if (_process(frag, raw_digits)) ++n_rce_frags;
	}
    }
  }
  else
  {
    art::Handle<artdaq::Fragments> frags;
    evt.getByLabel(_input_label, "TPC", frags);
    // Check if there is Timing data in this event
    // Don't crash code if not present, just don't save anything
    art::EventNumber_t eventNumber = evt.event();
    try { frags->size(); }
    catch(std::exception e) {
      std::cout << "WARNING: Raw TPC/RCE data not found in event " << eventNumber << std::endl;
      std::vector<raw::RawDigit> digits;
      evt.put(std::make_unique<std::vector<raw::RawDigit>>(std::move(digits)), _output_label);
      return;
    }

    //Check that the data is valid
    if(!frags.isValid()){
      LOG_ERROR("RceRawDecoder")
          << "Run: " << evt.run()
		  << ", SubRun: " << evt.subRun()
          << ", Event: " << evt.event()
		  << " Fragments is NOT VALID";
    }

    for(auto const& frag: *frags)
    {
      if (_process(frag, raw_digits)) ++n_rce_frags;
    }
  }

  LOG_INFO("RceRawDecoder")
      << " Processed " << n_rce_frags
      << " RCE Fragments, "
      << raw_digits.size()
      << " RawDigits.";

  evt.put(std::make_unique<decltype(raw_digits)>(std::move(raw_digits)),
          _output_label);
}

bool dune::RceRawDecoder::_process(
        const artdaq::Fragment& frag, 
        RawDigits& raw_digits
        )
{
  // FIXME: Remove hard-coded fragment type
  if((unsigned)frag.type() != 2) return false;

  LOG_INFO("RceRawDecoder")
      << "   SequenceID = " << frag.sequenceID()
      << "   fragmentID = " << frag.fragmentID()
      << "   fragmentType = " << (unsigned)frag.type()
      << "   Timestamp =  " << frag.timestamp();
  art::ServiceHandle<dune::PdChannelMapService> channelMap;
  dune::RceFragment rce(frag);
  
  uint32_t ch_counter = 0;
  for (int i = 0; i < rce.size(); ++i)
  {
     auto const * rce_stream = rce.get_stream(i);

     int n_ch = rce_stream->getNChannels();
     int n_ticks = rce_stream->getNTicks();

     LOG_INFO("RceRawDecoder")
         << "RceFragment timestamp: " << rce_stream->getTimeStamp()
         << ", NChannels: " << n_ch
         << ", NTicks: " << n_ticks;

     _h_nticks->Fill(n_ticks);

     size_t buffer_size = n_ch * n_ticks;
     if (_buffer.capacity() < buffer_size)
     {
         LOG_INFO("RceRawDecoder")
             << "Increase buffer size from " << _buffer.capacity()
             << " to " << buffer_size;

         _buffer.reserve(buffer_size);
     }

     uint16_t* adcs = _buffer.data();
     rce_stream->getMultiChannelData(adcs);

     raw::RawDigit::ADCvector_t v_adc;
     for (int i_ch = 0; i_ch < n_ch; i_ch++)
     {
        if(i==0 && i_ch ==0) std::cout<<" ADCs for the the 100 ticks in the 1st channel of the 1st RCE "<<std::endl;
        v_adc.clear();
        for (int i_tick = 0; i_tick < n_ticks; i_tick++)
        {
            //print ADCs for the the 100 ticks in the 1st channel of the 1st RCE
            if(i==0 && i_ch==0 && i_tick<100) {
              std::cout<<adcs[i_tick]<<"\t";
              if(i_tick==99) std::cout<<std::endl;
            }
            v_adc.push_back(adcs[i_tick]);
            _h_all_adc_values->Fill(adcs[i_tick]);
        }
        adcs += n_ticks;

        // FIXME Modify channel ID
        //int onlineChannel = frag.fragmentID() * 128 + i_ch; // 128 channels per RCE?
        int onlineChannel = channelMap->OnlineFromRCE(frag.fragmentID(), i_ch);
        ch_counter++;
        _h_online_channels->Fill(onlineChannel);
        int offlineChannel = -1;
        offlineChannel = channelMap->Offline(onlineChannel); // to get offline from online
        _h_offline_channels->Fill(offlineChannel);
        raw::RawDigit raw_digit(offlineChannel, n_ticks, v_adc);

        raw_digits.push_back(raw_digit);
     }
  }

  return true;
}

DEFINE_ART_MODULE(dune::RceRawDecoder)
