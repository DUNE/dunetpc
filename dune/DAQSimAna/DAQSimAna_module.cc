////////////////////////////////////////////////////////////////////////
// Class:       DAQSimAna
// Module Type: analyzer
// File:        DAQSimAna_module.cc
//
// Generated by Michael Baird using the old copy and paste...
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

// C++ includes

// ROOT includes
#include "TH1F.h"
#include "TH2F.h"

// Framework includes
#include "larcoreobj/SimpleTypesAndConstants/RawTypes.h"
#include "lardataobj/RawData/RawDigit.h"
#include "larcore/Geometry/Geometry.h"
#include "lardataobj/RawData/raw.h"
#include "lardataobj/Simulation/sim.h"
#include "lardataobj/Simulation/SimChannel.h"

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"


class DAQSimAna;

class DAQSimAna : public art::EDAnalyzer {

public:

  explicit DAQSimAna(fhicl::ParameterSet const & p);

  // Plugins should not be copied or assigned.
  DAQSimAna(DAQSimAna const &) = delete;
  DAQSimAna(DAQSimAna &&) = delete;
  DAQSimAna & operator = (DAQSimAna const &) = delete;
  DAQSimAna & operator = (DAQSimAna &&) = delete;

  // The main guts...
  void analyze(art::Event const & e) override;

  void reconfigure(fhicl::ParameterSet const & p);

  void beginJob();



private:

  // label for module that made raw digits
  std::string fRawDigitLabel;

  // other variables
  int nADC;

  // histograms to fill
  TH1F* fNADC_comp;
  TH1F* fNADC_nocomp;
  TH1F* fNADC_comp_rawcount;
  TH1F* fCompX;
  TH1F* fCompX_rawcount;
  TH2F* fCompX_vs_channel;
  TH2F* fCompX_vs_channel_rawcount;
  TH2F* fCompXr_vs_CompX;

  //Services
  art::ServiceHandle<geo::Geometry> geo;
  
};



//......................................................
DAQSimAna::DAQSimAna(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)
{
  this->reconfigure(p);
}



//......................................................
void DAQSimAna::reconfigure(fhicl::ParameterSet const & p)
{
  fRawDigitLabel = p.get<std::string> ("RawDigitLabel");  
}



//......................................................
void DAQSimAna::beginJob()
{

  art::ServiceHandle<art::TFileService> tfs;

  fNADC_comp = tfs->make<TH1F>("fNADC_comp","Number of ADC samples, after compression;Number of ADC samples;Frequency",5000,0,5000);
  fNADC_nocomp = tfs->make<TH1F>("fNADC_nocomp","Number of ADC samples, without compression;Number of ADC samples;Frequency",5000,0,5000);
  fNADC_comp_rawcount = tfs->make<TH1F>("fNADC_comp_rawcount","Number of ADC samples, after compression, by counting non-zero entries; Number of ADC samples; Frequency",5000,0,5000);
  fCompX =  tfs->make<TH1F>("fCompX","Compression Factor;Compression Factor;Frequency",100,0,1);
  fCompX_rawcount = tfs->make<TH1F>("fCompX_rawcount","Compression Factor, by counting non-zero entries;Compression Factor;Frequency",100,0,1);
  fCompX_vs_channel =  tfs->make<TH2F>("fCompX_vs_channel","Compression Factor vs. Channel No.;Channel No.;Compression Factor",30720,0,30720,100,0,1);
  fCompX_vs_channel_rawcount =  tfs->make<TH2F>("fCompX_vs_channel_rawcount","Compression Factor vs. Channel No., by counting non-zero entries;Channel No.;Compression Factor",30720,0,30720,100,0,1);
  fCompXr_vs_CompX = tfs->make<TH2F>("fCompXr_vs_CompX","Compression Factor vs. Compression Factor by counting non-zero entries;Compression Factor by counting non-zero entries;Compression Factor",1000,0,0.1,1000,0,0.1);

}



//......................................................
void DAQSimAna::analyze(art::Event const & e)
{

  //
  // Lift out the TPC raw digits:
  //
  art::Handle<std::vector<raw::RawDigit>> digitsHandle;
  e.getByLabel(fRawDigitLabel, digitsHandle);  
  std::cout << "\n\n\nraw_digits.size() = " << digitsHandle->size() << "\n\n\n";

  art::PtrVector<raw::RawDigit> rdvec;
  for (unsigned int i=0; i<digitsHandle->size(); ++i){
    art::Ptr<raw::RawDigit> r(digitsHandle,i);
    rdvec.push_back(r);
  }

  std::cout << "\n\n\nrdvec.size() = " << rdvec.size() << "\n\n\n";//6408 is...?

  std::vector<short> uADCs;
  
  for (unsigned int rd=0; rd<rdvec.size(); ++rd){
    
    nADC=0;
    
    //print some stuff (for debugging)
    if (rd==0){
      std::cout << "\n\n\nrdvec[rd]->Samples() = " << rdvec[rd]->Samples() << "\n\n\n";//4492 is readout length
      std::cout << "\n\n\nrdvec[rd]->NADC() = " <<rdvec[rd]->NADC() << "\n\n\n";//this is the readout length with compression
      std::cout << "\n\n\nrdvec[rd]->Channel() = " <<rdvec[rd]->Channel() << "\n\n\n";//this is the channel number for this raw digit
      
      std::cout << "\n";
      std::cout << "\nuADCs.size() before Uncompress = " << uADCs.size();
      raw::Uncompress(rdvec[rd]->ADCs(), uADCs, rdvec[rd]->Compression());
      std::cout << "\nuADCs.size() after Uncompress = " << uADCs.size() << "\n\n";
    }
    
    for (unsigned int a = 0; a < uADCs.size(); a++){
      if (uADCs[a]!=0){
	if (rd==0) std::cout << "ATTN:\t" << uADCs[a] << "\n";
	nADC++;
      }
    }
    if (rd==0) std::cout << "\n";
    if (rd==0) std::cout << "Found " << nADC << " non-zero ADC words in uncompressed waveform\n";

    fNADC_comp->Fill(rdvec[rd]->NADC());
    fNADC_nocomp->Fill(rdvec[rd]->Samples());
    fCompX->Fill(rdvec[rd]->NADC()/rdvec[rd]->Samples());
    fCompX_vs_channel->Fill(rdvec[rd]->Channel(),rdvec[rd]->NADC()/rdvec[rd]->Samples());

    fNADC_comp_rawcount->Fill(nADC);
    fCompX_rawcount->Fill(nADC/rdvec[rd]->Samples());
    fCompX_vs_channel_rawcount->Fill(rdvec[rd]->Channel(),nADC/rdvec[rd]->Samples());

    fCompXr_vs_CompX->Fill(rdvec[rd]->NADC()/rdvec[rd]->Samples(),nADC/rdvec[rd]->Samples());

  }

}

DEFINE_ART_MODULE(DAQSimAna)
