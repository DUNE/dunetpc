////////////////////////////////////////////////////////////////////////
// Class:       DAQSimAna
// Module Type: analyzer
// File:        DAQSimAna_module.cc
//
// Generated by Michael Baird using the old copy and paste...
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

// C++ includes

// ROOT includes
#include "TH1F.h"
#include "TH2F.h"
#include "TTree.h"

// Framework includes
#include "larcoreobj/SimpleTypesAndConstants/RawTypes.h"
#include "lardataobj/RawData/RawDigit.h"
#include "larcore/Geometry/Geometry.h"
#include "lardataobj/RawData/raw.h"
#include "lardataobj/Simulation/sim.h"
#include "lardataobj/Simulation/SimChannel.h"
#include "lardataobj/RecoBase/Hit.h"

#include "larsim/MCCheater/BackTracker.h"

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

const int nMaxHits = 1000;
const int nMaxDigs = 4492;

class DAQSimAna : public art::EDAnalyzer {

public:

  explicit DAQSimAna(fhicl::ParameterSet const & p);

  // Plugins should not be copied or assigned.
  DAQSimAna(DAQSimAna const &) = delete;
  DAQSimAna(DAQSimAna &&) = delete;
  DAQSimAna & operator = (DAQSimAna const &) = delete;
  DAQSimAna & operator = (DAQSimAna &&) = delete;

  // The main guts...
  void analyze(art::Event const & evt) override;

  void reconfigure(fhicl::ParameterSet const & p);

  void beginJob();

private:

  // --- Some of our own functions.
  void ResetVariables();

  // --- Our fcl parameter labels for the modules that made the data products
  std::string fRawDigitLabel;
  std::string fHitLabel;

  // --- Other variables
  int nADC;

  // --- Our TTree, and its associated variables.
  TTree* fDAQSimTree;
  // General event info.
  int Run;
  int SubRun;
  int Event;
  // Raw digits
  int NTotDigs;

  // Reconstructed hits
  int   NTotHits;
  int   NColHits;
  int   NIndHits; 
  int   HitView[nMaxHits]; ///< View i.e Coll, U, V
  int   HitSize[nMaxHits]; ///< Time width (ticks) Start - End time
  int   HitChan[nMaxHits]; ///< The channel which the hit occurs on
  float HitTime[nMaxHits]; ///< The time of the hit (ticks)
  float HitRMS [nMaxHits]; ///< The RMS of the hit
  float HitSADC[nMaxHits]; ///< The summed ADC of the hit
  float HitInt [nMaxHits]; ///< The ADC integral of the hit
  float HitPeak[nMaxHits]; ///< The peak ADC value of the hit
  int   TotHitSize;

  // histograms to fill about raw digits
  TH1F* fNADC_comp;
  TH1F* fNADC_nocomp;
  TH1F* fNADC_comp_rawcount;
  TH1F* fCompX;
  TH1F* fCompX_rawcount;
  TH2F* fCompX_vs_channel;
  TH2F* fCompX_vs_channel_rawcount;
  TH2F* fCompXr_vs_CompX;

  // histograms to fill about reco hits
  TH1F* fNHits_tot;
  TH1F* fHitSize_tot;

  TH1F* fNHits_ind;
  TH1F* fHitSize_ind;

  TH1F* fNHits_col;
  TH1F* fHitSize_col;

  TH1F* fEventSize;
  TH1F* fHitView;

  // --- Declare our services
  art::ServiceHandle<geo::Geometry> geo;
  art::ServiceHandle<cheat::BackTracker> backtracker;
  
};

//......................................................
DAQSimAna::DAQSimAna(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p)
{
  this->reconfigure(p);
}

//......................................................
void DAQSimAna::reconfigure(fhicl::ParameterSet const & p)
{
  fRawDigitLabel = p.get<std::string> ("RawDigitLabel");  
  fHitLabel      = p.get<std::string> ("HitLabel");
} // Reconfigure

//......................................................
void DAQSimAna::ResetVariables()
{
  // General event info.
  Run = SubRun = Event = -1;
  // raw digits
  
  // reconstructed hits
  NTotHits = NColHits = NIndHits = 0; 
  TotHitSize = 0;
  for (int hh=0; hh<nMaxHits; ++hh) {
    HitView[hh] = HitSize[hh] = HitChan[hh] = 0;
    HitTime[hh] = HitRMS [hh] = HitSADC[hh] = 0;
    HitInt [hh] = HitPeak[hh] = 0;
  }
} // ResetVariables

//......................................................
void DAQSimAna::beginJob()
{
  // --- Make our handle to the TFileService
  art::ServiceHandle<art::TFileService> tfs;
  // --- Our TTree
  fDAQSimTree = tfs->make<TTree>("DAQSimTree","DAQ simulation analysis tree");
  // General event information...
  fDAQSimTree -> Branch( "Run"   , &Run   , "Run/I"    );
  fDAQSimTree -> Branch( "SubRun", &SubRun, "SubRun/I" );
  fDAQSimTree -> Branch( "Event" , &Event , "Event/I"  );
  // Reconstructed hits...
  fDAQSimTree -> Branch( "NTotHits"  , &NTotHits  , "NTotHits/I" );
  fDAQSimTree -> Branch( "NColHits"  , &NColHits  , "NColHits/I" );
  fDAQSimTree -> Branch( "NIndHits"  , &NIndHits  , "NIndHits/I" );
  fDAQSimTree -> Branch( "HitView"   , &HitView   , "HitView[NTotHits]/I" );
  fDAQSimTree -> Branch( "HitSize"   , &HitSize   , "HitSize[NTotHits]/I" );
  fDAQSimTree -> Branch( "HitChan"   , &HitChan   , "HitChan[NTotHits]/I" );
  fDAQSimTree -> Branch( "HitTime"   , &HitTime   , "HitTime[NTotHits]/F" );
  fDAQSimTree -> Branch( "HitRMS"    , &HitRMS    , "HitRMS[NTotHits]/F"  );
  fDAQSimTree -> Branch( "HitSADC"   , &HitSADC   , "HitSADC[NTotHits]/F" );
  fDAQSimTree -> Branch( "HitInt"    , &HitInt    , "HitInt[NTotHits]/F"  );
  fDAQSimTree -> Branch( "HitPeak"   , &HitPeak   , "HitPeak[NTotHits]/F" );
  fDAQSimTree -> Branch( "TotHitSize", &TotHitSize, "TotHitSize/I" );

  // --- Our Histograms...
  fNADC_comp = tfs->make<TH1F>("fNADC_comp","Number of ADC samples, after compression;Number of ADC samples;Frequency",5000,0,5000);
  fNADC_nocomp = tfs->make<TH1F>("fNADC_nocomp","Number of ADC samples, without compression;Number of ADC samples;Frequency",5000,0,5000);
  fNADC_comp_rawcount = tfs->make<TH1F>("fNADC_comp_rawcount","Number of ADC samples, after compression, by counting non-zero entries; Number of ADC samples; Frequency",5000,0,5000);
  fCompX =  tfs->make<TH1F>("fCompX","Compression Factor;Compression Factor;Frequency",100,0,1);
  fCompX_rawcount = tfs->make<TH1F>("fCompX_rawcount","Compression Factor, by counting non-zero entries;Compression Factor;Frequency",100,0,1);
  fCompX_vs_channel =  tfs->make<TH2F>("fCompX_vs_channel","Compression Factor vs. Channel No.;Channel No.;Compression Factor",30720,0,30720,100,0,1);
  fCompX_vs_channel_rawcount =  tfs->make<TH2F>("fCompX_vs_channel_rawcount","Compression Factor vs. Channel No., by counting non-zero entries;Channel No.;Compression Factor",30720,0,30720,100,0,1);
  fCompXr_vs_CompX = tfs->make<TH2F>("fCompXr_vs_CompX","Compression Factor vs. Compression Factor by counting non-zero entries;Compression Factor by counting non-zero entries;Compression Factor",1000,0,0.1,1000,0,0.1);

  fNHits_tot = tfs->make<TH1F>("fNHits_tot",
			       "Total number of reco hits per art::event;NHits;",
			       1000,0.0,5000.0);

  fHitSize_tot = tfs->make<TH1F>("fHitSize_tot",
				 "Hit Duration (all hits);# of ticks;",
				 101,-0.5,100.5);

  fNHits_ind = tfs->make<TH1F>("fNHits_ind",
			       "Number of induction plane reco hits per art::event;NHits;",
			       1000,0.0,5000.0);

  fHitSize_ind = tfs->make<TH1F>("fHitSize_ind",
				 "Hit Duration (induction plane hits);# of ticks;",
				 101,-0.5,100.5);

  fNHits_col = tfs->make<TH1F>("fNHits_col",
			       "Number of collection reco hits per art::event;NHits;",
			       1000,0.0,5000.0);

  fHitSize_col = tfs->make<TH1F>("fHitSize_col",
				 "Hit Duration (collection plane hits);# of ticks;",
				 101,-0.5,100.5);

  fEventSize = tfs->make<TH1F>("fEventSize",
			       "Size of event (sum over all hits);# of ticks;",
			       500,0.0,50000.0);

  fHitView = tfs->make<TH1F>("fHitView",
			     "Hit view (U,V,Z);view;",
			     16,-5.5,10.5);
} // BeginJob

//......................................................
void DAQSimAna::analyze(art::Event const & evt)
{

  // --- We want to reset all of our TTree variables...
  ResetVariables();
 
  // --- Set all of my general event information...
  Run    = evt.run();
  SubRun = evt.subRun();
  Event  = evt.event();

  // --- Lift out the TPC raw digits:
  auto rawdigits = evt.getValidHandle<std::vector<raw::RawDigit> >(fRawDigitLabel);

  // --- Lift out the reco hits:
  auto reco_hits = evt.getValidHandle<std::vector<recob::Hit> >(fHitLabel);

  // --- Loop over the reconstructed hits to determine the "size" of each hit 
  NTotHits = reco_hits->size();
  for(int hit = 0; hit < NTotHits; ++hit) {
    // --- Let access this particular hit.
    recob::Hit const& ThisHit = reco_hits->at(hit);  
    
    // --- Now fill in all of the hit level variables.
    HitView[hit] = ThisHit.View();
    HitSize[hit] = ThisHit.EndTick() - ThisHit.StartTick();
    HitChan[hit] = ThisHit.Channel();
    HitTime[hit] = ThisHit.PeakTime();
    HitRMS [hit] = ThisHit.RMS();
    HitSADC[hit] = ThisHit.SummedADC();
    HitInt [hit] = ThisHit.Integral();
    HitPeak[hit] = ThisHit.PeakAmplitude();

    std::cout << " Peak " << HitPeak[hit] << " " << ThisHit.PeakAmplitude() 
	      << " Time " << HitTime[hit] << " " << ThisHit.PeakTime()
	      << " SADC " << HitSADC[hit] << " " << ThisHit.SummedADC()
	      << std::endl;

    // --- Work out the total hit size of the event.
    TotHitSize += HitSize[hit];
    
    // --- Check which view this hit is on...
    if(ThisHit.View() == geo::kU || ThisHit.View() == geo::kV) {
      ++NIndHits;
    } else { // If not induction then must be collection.
      ++NColHits;
    }    
  } // Loop over reco_hits.


  std::vector<short> uADCs;
  
  for (unsigned int dig=0; dig<rawdigits->size(); ++dig){
    
    // --- Lets access this particular RawDigit
    raw::RawDigit ThisDig = rawdigits->at(dig);
    nADC=0;

    // --- Uncompress the ADC vector.
    if (dig==0){
      std::cout << "uADCs.size() before Uncompress = " << uADCs.size() << std::endl;
      raw::Uncompress(ThisDig.ADCs(), uADCs, ThisDig.Compression());
      std::cout << "uADCs.size() after Uncompress = " << uADCs.size() << "\n\n";
    }
    
    //print some stuff (for debugging)
    if (dig==0){
      std::cout << "\nLooking at rawdigit["<<dig<<"]. It was on channel " << ThisDig.Channel() << ". "
		<< "It had " << ThisDig.Samples() << " samples. "                                 // The readout length for 1x2x6 is 4492 ticks
		<< "There were a total of " << ThisDig.NADC() << " ADCs saved with compression " // This is the readout length with compression
		<< "level " << ThisDig.Compression()
		<< std::endl;
    }
    
    for (unsigned int a = 0; a < uADCs.size(); a++){
      if (uADCs[a]!=0){
	if (dig==0) std::cout << "ATTN:\t" << uADCs[a] << " - " << ThisDig.GetPedestal() << " = " << uADCs[a]-ThisDig.GetPedestal() << "....Dig " << dig << ", tick " << a << ".\n";
	nADC++;
      }
    }
    if (dig==0) std::cout << "\n";
    if (dig==0) std::cout << "Found " << nADC << " non-zero ADC words in uncompressed waveform\n";

    fNADC_comp->Fill(ThisDig.NADC());
    fNADC_nocomp->Fill(ThisDig.Samples());
    fCompX->Fill(ThisDig.NADC()/ThisDig.Samples());
    fCompX_vs_channel->Fill(ThisDig.Channel(),ThisDig.NADC()/ThisDig.Samples());

    fNADC_comp_rawcount->Fill(nADC);
    fCompX_rawcount->Fill(nADC/ThisDig.Samples());
    fCompX_vs_channel_rawcount->Fill(ThisDig.Channel(),nADC/ThisDig.Samples());

    fCompXr_vs_CompX->Fill(ThisDig.NADC()/ThisDig.Samples(),nADC/ThisDig.Samples());

  } // Loop over RawDigits.
  
  // --- Finally, fill our TTree once per event.
  fDAQSimTree -> Fill();

} // Analyze DAQSimAna.

DEFINE_ART_MODULE(DAQSimAna)
