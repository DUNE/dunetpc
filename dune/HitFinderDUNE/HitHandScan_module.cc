////////////////////////////////////////////////////////////////////////
// Class:       HitHandScan
// Module Type: producer
// File:        HitHandScan_module.cc
//
// Generated at Tue May  3 01:14:23 2016 by Matthew Thiesse using artmod
// from cetpkgsupport v1_10_01.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "art/Framework/Core/FindOneP.h"
#include "larcore/SimpleTypesAndConstants/geo_types.h"
#include "lardata/RecoBase/Hit.h"
#include "lardata/RecoBase/Wire.h"
#include "lardata/RawData/RawDigit.h"
#include "lardata/RecoBaseArt/HitCreator.h"
#include "lardata/Utilities/AssociationUtil.h"

#include <sstream>
#include <string>
#include <fstream>
#include <vector>
#include <memory>
#include <map>

#include "TMath.h"

class HitHandScan;

typedef struct {
  double tick;// IN RELATION TO EXTERNAL TRIGGER, NOT NECESSARILY THE FIRST TICK IN THE EVENT
  unsigned int tpc;
  unsigned int wire;// wire number in this tpc (usually 0-111 for coll planes)
} Point;

class HitHandScan : public art::EDProducer {
public:
  explicit HitHandScan(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  HitHandScan(HitHandScan const &) = delete;
  HitHandScan(HitHandScan &&) = delete;
  HitHandScan & operator = (HitHandScan const &) = delete;
  HitHandScan & operator = (HitHandScan &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void reconfigure(fhicl::ParameterSet const & p) override;

private:
  bool insidePolygon(std::vector<Point> polygon, Point ptest);
  double angle2D(Point p1, Point p2);

  std::string fPreviousHitModuleLabel;
  std::string fHandScanFileName;
  int fPreTriggerTicks;

  std::map<int,std::vector<Point> > trackBox;

};


HitHandScan::HitHandScan(fhicl::ParameterSet const & p)
{
  this->reconfigure(p);
  recob::HitCollectionCreator::declare_products(*this);
}

void HitHandScan::produce(art::Event & e)
{
  art::Handle< std::vector< recob::Hit> > prevHitHandle;
  e.getByLabel(fPreviousHitModuleLabel,prevHitHandle);

  art::FindOneP<recob::Wire> wires(prevHitHandle,e,fPreviousHitModuleLabel);
  art::FindOneP<raw::RawDigit> rawdigits(prevHitHandle,e,fPreviousHitModuleLabel);

  recob::HitCollectionCreator hcol(*this, e, wires.isValid(), rawdigits.isValid());
  
  std::string readrun,readevent,readtpc,readwire,readtick,readnumpoly;
  std::string line;
  std::ifstream handscanfile(fHandScanFileName.c_str(),std::ifstream::in);
  if (handscanfile.is_open())
    {
      while (std::getline(handscanfile,line))
	{
	  std::stringstream ss(line);
	  ss >> readrun >> readevent >> readtpc >> readwire >> readtick >> readnumpoly;
	  if (stoul(readrun) == e.run() && stoul(readevent) == e.event())
	    {
	      Point p;
	      p.tick = stod(readtick);
	      p.tpc = stoul(readtpc);
	      p.wire = stoul(readwire);
	      trackBox[stoi(readnumpoly)].push_back(p);
	    }
	}
      handscanfile.close();
    }
  else
    {
      std::cout << "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!\n"
		<< "NO FILE FOUND WITH HAND SCANNED HIT DATA\n"
		<< "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
      return;
    }

  for (size_t i_hit = 0; i_hit < prevHitHandle->size(); i_hit++)
    {
      art::Ptr<recob::Hit> phit(prevHitHandle,i_hit);
      if (phit->View() != geo::kZ) continue;

      art::Ptr<recob::Wire> wire(wires.at(i_hit));
      art::Ptr<raw::RawDigit> rawdigit(rawdigits.at(i_hit));

      bool acceptPoint = false;
      for (auto poly = trackBox.begin(); poly != trackBox.end(); poly++)
	{
	  std::vector<Point> polygon = (*poly).second;
	  Point ptest;
	  ptest.wire = phit->WireID().Wire;
	  ptest.tpc = phit->WireID().TPC;
	  ptest.tick = phit->PeakTime()-fPreTriggerTicks;
	  if (insidePolygon(polygon,ptest)) acceptPoint = true;
	}
      if (acceptPoint) 
	{
	  hcol.emplace_back(*phit,wire,rawdigit);
	}
    }
  
  hcol.put_into(e);

}

void HitHandScan::reconfigure(fhicl::ParameterSet const & p)
{
  fHandScanFileName = p.get<std::string>("HandScanFileName");
  fPreviousHitModuleLabel = p.get<std::string>("PreviousHitModuleLabel");
  fPreTriggerTicks = p.get<int>("PreTriggerTicks");
}

bool HitHandScan::insidePolygon(std::vector<Point> polygon, Point ptest)
{
  Point p1,p2;
  double angle=0;
  size_t n = polygon.size();
  for (size_t i = 0; i < n; i++)
    {
      p1.tpc = polygon[i].tpc;
      p1.wire = polygon[i].wire - ptest.wire;
      p1.tick = polygon[i].tick - ptest.tick;
      p2.tpc = polygon[(i+1)%n].tpc;
      p2.wire = polygon[(i+1)%n].wire - ptest.wire;
      p2.tick = polygon[(i+1)%n].tick - ptest.wire;
      angle += angle2D(p1,p2);
    }
  if (TMath::Abs(angle) < TMath::Pi()) return false;
  return true;
}

double HitHandScan::angle2D(Point p1, Point p2)
{
  double theta1 = TMath::ATan2(p1.tick,p1.wire);
  double theta2 = TMath::ATan2(p2.tick,p2.wire);
  double dtheta = theta2 - theta1;
  while (dtheta > TMath::Pi()) dtheta -= 2*TMath::Pi();
  while (dtheta < -TMath::Pi()) dtheta += 2*TMath::Pi();
  return dtheta;
}



DEFINE_ART_MODULE(HitHandScan)
