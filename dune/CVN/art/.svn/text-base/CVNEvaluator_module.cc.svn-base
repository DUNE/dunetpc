////////////////////////////////////////////////////////////////////////
// \file    CVNEvaluator_module.cc
// \brief   Producer module creating CVN neural net results
// \author  Dominick Rocco - rocco@physics.umn.edu
////////////////////////////////////////////////////////////////////////

// C/C++ includes
#include <iostream>
#include <sstream>

// ROOT includes
#include "TFile.h"
#include "TH2F.h"
#include "TMatrixD.h"
#include "TTree.h"
#include "TVectorD.h"

// Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Core/FindManyP.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Persistency/Common/Assns.h"

// NOvASoft includes
#include "RecoBase/Cluster.h"
#include "RecoBase/FilterList.h"
#include "Utilities/AssociationUtil.h"


#include "CVN/func/PixelMap.h"
#include "CVN/func/Result.h"
#include "CVN/func/Features.h"
#include "CVN/art/CaffeNetHandler.h"
#include "CVN/func/InteractionType.h"




namespace cvn {

  class CVNEvaluator : public art::EDProducer {
  public:
    explicit CVNEvaluator(fhicl::ParameterSet const& pset);
    ~CVNEvaluator();

    void produce(art::Event& evt);
    void beginJob();
    void endJob();



  private:
    std::vector<float> PrincipalComponents(const float* feat);

    /// Module lablel for input clusters
    std::string    fClusterLabel;

    /// Module label for input pixel maps
    std::string fPixelMapInput;

    ///  Check rb::IsFiltered?
    bool        fObeyPreselection;
    std::vector<std::string> fPreselectionLabels;


    //
    cvn::CaffeNetHandler fHandler;

    /// Number of outputs fron neural net
    unsigned int fNOutput;
    unsigned int fNFeatures;

    /// Location to fetch the coefficients for the principal components from
    std::string fEigenvectorFilename;
    TMatrixF fEigenvectors;
  };



  //.......................................................................
  CVNEvaluator::CVNEvaluator(fhicl::ParameterSet const& pset):
  fClusterLabel  (pset.get<std::string>         ("ClusterLabel")),
  fPixelMapInput (pset.get<std::string>         ("PixelMapInput")),
  fObeyPreselection (pset.get<bool>             ("ObeyPreselection")),
  fPreselectionLabels (pset.get<std::vector<std::string>>
                                                ("PreselectionLabels")),
  fHandler       (pset.get<fhicl::ParameterSet> ("CaffeNetHandler")),
  fNOutput       (fHandler.NOutput()),
  fNFeatures       (fHandler.NFeatures()),
  fEigenvectorFilename(pset.get<std::string>    ("EigenvectorFilename"))
  {
    produces< std::vector<cvn::Result>   >();
    produces< art::Assns<cvn::Result, rb::Cluster> >();
    produces< std::vector<cvn::Features>   >();
    produces< art::Assns<cvn::Features, rb::Cluster> >();
  }

  //......................................................................
  CVNEvaluator::~CVNEvaluator()
  {
    //======================================================================
    // Clean up any memory allocated by your module
    //======================================================================
  }

  //......................................................................
  void CVNEvaluator::beginJob()
  {  }

  //......................................................................
  void CVNEvaluator::endJob()
  {
  }

  //......................................................................
  void CVNEvaluator::produce(art::Event& evt)
  {

    /// Define containers for the things we're going to produce
    std::unique_ptr< std::vector<Result> >
                                  resultCol(new std::vector<Result>);
    std::unique_ptr< art::Assns<Result, rb::Cluster> >
                                  assoc(new art::Assns<Result, rb::Cluster>);
    std::unique_ptr< std::vector<Features> >
                                  featureCol(new std::vector<Features>);
    std::unique_ptr< art::Assns<Features, rb::Cluster> >
                                  assocFeatures(new art::Assns<Features, rb::Cluster>);

    // get the slices
    art::Handle< std::vector< rb::Cluster > > clusterHandle;
    evt.getByLabel(fClusterLabel, clusterHandle);
    const std::vector<rb::Cluster> & clusters = *clusterHandle;


    art::PtrVector<rb::Cluster>  sliceCol;
    for(unsigned int i = 0; i<clusterHandle->size();++i){
      art::Ptr<rb::Cluster> clust(clusterHandle,i);
      sliceCol.push_back(clust);
    }


    art::FindManyP<PixelMap> fmPixelMap(clusterHandle, evt, fPixelMapInput);


    for(size_t iClust = 0; iClust < clusters.size(); ++iClust) {
      if(!fmPixelMap.isValid()) continue;
      if(fObeyPreselection && rb::IsFiltered(evt,clusterHandle, iClust,
                                             fPreselectionLabels))
        continue;

      const std::vector<art::Ptr<PixelMap> > pixelMaps = fmPixelMap.at(iClust);

      if(pixelMaps.empty()) continue;

      std::pair<const float*, const float*> pairedoutput= fHandler.Predict(*pixelMaps[0]);
      const float* output=pairedoutput.first;
      const float* features=pairedoutput.second;
      std::vector<float> components = PrincipalComponents(features);

      resultCol->emplace_back(output, fNOutput);
      featureCol->emplace_back(features, &components.front(), fNFeatures);
      util::CreateAssn(*this, evt, *(resultCol.get()),
                       sliceCol[iClust], *(assoc.get()),  UINT_MAX);

      util::CreateAssn(*this, evt, *(featureCol.get()),
                       sliceCol[iClust], *(assocFeatures.get()),  UINT_MAX);
    }

    evt.put(std::move(resultCol));
    evt.put(std::move(assoc));
    evt.put(std::move(featureCol));
    evt.put(std::move(assocFeatures));


  }

  //----------------------------------------------------------------------

  std::vector<float> CVNEvaluator::PrincipalComponents(const float* feat)
  {
    if(fEigenvectors.GetNrows() == 0){
      cet::search_path sp("FW_SEARCH_PATH");
      std::string fname;
      sp.find_file(fEigenvectorFilename, fname);
      if(fname.empty()){
        std::cout << "Couldn't find " << fEigenvectorFilename
                  << " in $FW_SEARCH_PATH. Aborting" << std::endl;
        abort();
      }

      std::cout << "Loading CVN eigenvector matrix from "
                << fname << std::endl;

      TFile f(fname.c_str());
      assert(!f.IsZombie());
      TTree* tr = (TTree*)f.Get("t");
      assert(tr);

      const int N = tr->GetEntries();
      fEigenvectors.ResizeTo(N, N);
      double row[N]; // square matrix, same number of rows and columns
      tr->SetBranchAddress("Array", &row);

      for(int i = 0; i < N; ++i){
        tr->GetEntry(i);
        for(int j = 0; j < N; ++j){
          fEigenvectors(i, j) = row[j];
        }
      }
      std::cout << "Got " << N << "x" << N << " matrix" << std::endl;
    }

    const TVectorF featvec(fNFeatures, feat);

    const TVectorF retvec = fEigenvectors*featvec;

    return std::vector<float>(retvec.GetMatrixArray(),
                              retvec.GetMatrixArray()+retvec.GetNrows());
  }


  DEFINE_ART_MODULE(cvn::CVNEvaluator);
} // end namespace cvn
////////////////////////////////////////////////////////////////////////







