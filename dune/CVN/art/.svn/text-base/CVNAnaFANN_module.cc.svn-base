////////////////////////////////////////////////////////////////////////
// \file    CVNAnaFANN_module.cc
// \brief   Analyzer module for testing CVN performace
// \author  Dominick Rocco - rocco@physics.umn.edu
////////////////////////////////////////////////////////////////////////

// C/C++ includes
#include <iostream>
#include <string>
#include <sstream>

// FANN includes
#include "floatfann.h"
#include "fann_cpp.h"

// ROOT includes
#include "TTree.h"
#include "TH2F.h"
#include "TH3F.h"

// Framework includes
#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Core/FindManyP.h"


// NOvASoft includes
#include "RecoBase/CellHit.h"
#include "RecoBase/Cluster.h"
#include "Utilities/AssociationUtil.h"
#include "SimulationBase/MCNeutrino.h"
#include "SimulationBase/MCParticle.h"
#include "SimulationBase/MCTruth.h"

#include "Calibrator/Calibrator.h"
#include "MCCheater/BackTracker.h"

#include "CVN/art/PixelMapProducer.h"
#include "CVN/func/AssignLabels.h"
#include "CVN/func/TrainingData.h"
#include "CVN/func/InteractionType.h"



namespace cvn {
  class CVNAnaFANN : public art::EDAnalyzer {
  public:
    explicit CVNAnaFANN(fhicl::ParameterSet const& pset);
    ~CVNAnaFANN();

    void analyze(const art::Event& evt);
    void reconfigure(const fhicl::ParameterSet& pset);
    void beginJob();
    void endJob();



  private:
    /// Module lablel for input clusters
    std::string    fClusterLabel;

    /// Module label for input pixel maps
    std::string fPixelMapInput;


    /// Name of trained neural network file
    std::string fTrainedNetFile;

    // Neural network object
    FANN::neural_net fNN;

    /// Number of outputs fron neural net
    unsigned int fNOutput;

    TH2F* fConfusionMatrix;
    TH3F* fCMRecoE;
    TH3F* fCMTrueE;


    std::ofstream fEventListFile;

    art::ServiceHandle<cheat::BackTracker> fBT;


  };



  //.......................................................................
  CVNAnaFANN::CVNAnaFANN(fhicl::ParameterSet const& pset)
    : EDAnalyzer(pset),
    fEventListFile("event-list.txt")
  {
    this->reconfigure(pset);
  }

  //......................................................................
  CVNAnaFANN::~CVNAnaFANN()
  {
    //======================================================================
    // Clean up any memory allocated by your module
    //======================================================================
  }

  //......................................................................
  void CVNAnaFANN::reconfigure(const fhicl::ParameterSet& pset)
  {
    fClusterLabel   = pset.get<std::string>("ClusterLabel");
    fPixelMapInput  = pset.get<std::string>("PixelMapInput");
    fTrainedNetFile = pset.get<std::string>  ("TrainedNetFile");
  }

  //......................................................................
  void CVNAnaFANN::beginJob()
  {


    bool success = fNN.create_from_file(fTrainedNetFile);
    if (not success) throw cet::exception("Failed to open neural network file:")
      << fTrainedNetFile << std::endl;

    fNN.print_parameters();

    fNOutput = fNN.get_num_output();


    art::ServiceHandle<art::TFileService> tfs;

    fConfusionMatrix =  tfs->make<TH2F>("ConfusionMatrix",
                              ";True Interaction Type; Idenitfied Type;",
                              fNOutput, 0, fNOutput, fNOutput, 0, fNOutput);

    fCMRecoE         =  tfs->make<TH3F>("CMRecoE",
                              ";True Interaction Type; Idenitfied Type; Reco E",
                              fNOutput, 0, fNOutput,
                              fNOutput, 0, fNOutput,
                              20, 0, 10);

    fCMTrueE         =  tfs->make<TH3F>("CMTrueE",
                              ";True Interaction Type; Idenitfied Type; Reco E",
                              fNOutput, 0, fNOutput,
                              fNOutput, 0, fNOutput,
                              20, 0, 10);
    // ADD THIS LATER?
    ///fCMTrueVisE      =  tfs->make<TH2F>("CMRecoE",
    ///                          ";True Interaction Type; Idenitfied Type; Reco E",
    ///                          fNOutput, 0, fNOutput,
    ///                          fNOutput, 0, fNOutput
    ///                          20, 0, 10);




  }

  //......................................................................
  void CVNAnaFANN::endJob()
  {

  }

  //......................................................................
  void CVNAnaFANN::analyze(const art::Event& evt)
  {


    InteractionType interaction = kOther;
    simb::MCTruth truth;

    if(fBT->HaveTruthInfo()){
      std::vector<cheat::NeutrinoWithIndex> allNu = fBT->allMCTruth();
      if(allNu.size() == 1) truth = *(allNu[0].neutrinoInt);
      else if(allNu.size() == 0) truth = simb::MCTruth();
      else throw cet::exception("Can't handle more than one truth right now.");
    }else truth = simb::MCTruth();

    interaction = GetInteractionType(truth);
    float nuEnergy = 0;
    float lepEnergy = 0;
    if(truth.NeutrinoSet()){
      nuEnergy = truth.GetNeutrino().Nu().E();
      lepEnergy = truth.GetNeutrino().Lepton().E();
    }

    // get the slices
    art::Handle< std::vector< rb::Cluster > > clusterHandle;
    evt.getByLabel(fClusterLabel, clusterHandle);
    const std::vector<rb::Cluster> & clusters = *clusterHandle;


    art::FindManyP<PixelMap> fmPixelMap(clusterHandle, evt, fPixelMapInput);




    for(size_t iClust = 0; iClust < clusters.size(); ++iClust) {

      const rb::Cluster& cluster = clusters[iClust];


      if(!fmPixelMap.isValid()) continue;


      const std::vector<art::Ptr<PixelMap>> pixelMaps = fmPixelMap.at(iClust);

      if(pixelMaps.empty()) continue;

      TrainingData train(interaction, nuEnergy, lepEnergy, *pixelMaps[0]);

      float* output =  fNN.run(&train.fPMap.fPE[0]);

      float maxVal = 0;
      InteractionType idenifiedType = kOther;



      for(unsigned int iType = 0; iType < fNOutput; ++iType){
        /// NOTE!!! excluding the rare and nonexistent things!!!
        if(iType == kNueOther) continue;
        if(iType == kCosmic) continue;
        if(iType == kOther) continue;
        //std::cout << "i " << iType << " val " << output[iType] << std::endl;
        if(output[iType] > maxVal){
          maxVal = output[iType];
          idenifiedType = (InteractionType)iType;

        }
      }

      if (fNOutput == kNSimpleNeutrinoType)
      {
        interaction = (InteractionType)GetSimpleNeutrinoType(interaction);
      }

      if(interaction != idenifiedType &&  interaction == (InteractionType)kNumu)
      {
        fEventListFile << evt.run() << "  " << evt.subRun()
                       << "  " << evt.event() << "  " << iClust << std::endl;

        //std::cout << "wrong:" << output[0] << "  " << output[1] << "  " << output[2] << std::endl;
      }
      else{
        //std::cout << "right:" << output[0] << "  " << output[1] << "  " << output[2] << std::endl;
      }

      //std::cout << "pid " << idenifiedType << " val " << maxVal << std::endl;
      fConfusionMatrix->Fill(interaction, idenifiedType);
      fCMRecoE        ->Fill(interaction, idenifiedType,
                                        cluster.CalorimetricEnergy());
      fCMTrueE        ->Fill(interaction, idenifiedType,
                                         truth.GetNeutrino().Nu().E());
      //fCMTrueVisE     ->Fill(interaction, idenifiedType);


    }



  }

  //----------------------------------------------------------------------


DEFINE_ART_MODULE(cvn::CVNAnaFANN);
} // end namespace cvn
////////////////////////////////////////////////////////////////////////







