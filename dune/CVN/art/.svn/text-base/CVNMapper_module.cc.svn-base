////////////////////////////////////////////////////////////////////////
// \file    CVNMapper_module.cc
// \brief   Producer module for creating CVN PixelMap objects
// \author  Dominick Rocco - rocco@physics.umn.edu
////////////////////////////////////////////////////////////////////////

// C/C++ includes
#include <iostream>
#include <sstream>

// ROOT includes
#include "TTree.h"
#include "TH2F.h"

// Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Core/FindManyP.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Persistency/Common/Assns.h"

// NOvASoft includes
#include "RecoBase/CellHit.h"
#include "RecoBase/Cluster.h"
#include "RecoBase/FilterList.h"

#include "Utilities/AssociationUtil.h"
#include "SimulationBase/MCNeutrino.h"
#include "SimulationBase/MCParticle.h"
#include "SimulationBase/MCTruth.h"

#include "Calibrator/Calibrator.h"
#include "MCCheater/BackTracker.h"

#include "CVN/art/PixelMapProducer.h"
#include "CVN/func/PixelMap.h"
#include "CVN/func/TrainingData.h"




namespace cvn {

  class CVNMapper : public art::EDProducer {
  public:
    explicit CVNMapper(fhicl::ParameterSet const& pset);
    ~CVNMapper();

    void produce(art::Event& evt);
    void beginJob();
    void endJob();



  private:
    /// Module lablel for input clusters
    std::string    fClusterLabel;

    /// Module lablel for input prongs
    std::string    fProngModLabel;

    /// Instance lablel for input 3D prongs
    std::string    fProng3DLabel;

    /// Instance lablel for input 2D prongs
    std::string    fProng2DLabel;

    /// Instance lablel for cluster pixelmaps
    std::string    fClusterPMLabel;

    /// Instance lablel for prong pixelmaps
    std::string    fProngPMLabel;

    /// Option to save maps for prongs
    bool           fMapProngs;

    ///  Check rb::IsFiltered?
    bool        fObeyPreselection;

    /// Minimum number of hits for cluster to be converted to pixel map
    unsigned short fMinClusterHits;

    /// Width of pixel map in cells
    unsigned short fCellWidth;

    /// Length of pixel map in planes
    unsigned short fPlaneLength;

    /// Maximum gap in planes at front of cluster to prevent pruning of upstream
    /// hits
    unsigned int fMaxPlaneGap;

    /// true=GeV, false=PECorr
    bool         fUseGeV;
      
    /// PixelMapProducer does the work for us
    PixelMapProducer fProducer;

  };



  //.......................................................................
  CVNMapper::CVNMapper(fhicl::ParameterSet const& pset):
  fClusterLabel  (pset.get<std::string>    ("ClusterLabel")),
  fProngModLabel (pset.get<std::string>    ("ProngModLabel")),
  fProng3DLabel  (pset.get<std::string>    ("Prong3DLabel")),
  fProng2DLabel  (pset.get<std::string>    ("Prong2DLabel")),
  fClusterPMLabel(pset.get<std::string>    ("ClusterPMLabel")),
  fProngPMLabel  (pset.get<std::string>    ("ProngPMLabel")),
  fMapProngs     (pset.get<bool>           ("MapProngs")),
  fObeyPreselection(pset.get<bool>        ("ObeyPreselection")),
  fMinClusterHits(pset.get<unsigned short> ("MinClusterHits")),
  fCellWidth     (pset.get<unsigned short> ("CellWidth")),
  fPlaneLength   (pset.get<unsigned short> ("PlaneLength")),
  fMaxPlaneGap   (pset.get<unsigned int>   ("MaxPlaneGap")),
  fUseGeV        (pset.get<bool>           ("UseGeV")),
  fProducer      (fPlaneLength, fCellWidth, fMaxPlaneGap, fUseGeV)
  {

    produces< std::vector<cvn::PixelMap>   >(fClusterPMLabel);
    produces< std::vector<cvn::PixelMap>   >(fProngPMLabel);
    produces< art::Assns<cvn::PixelMap, rb::Cluster> >();
    produces< art::Assns<cvn::PixelMap, rb::Prong>   >();
  }

  //......................................................................
  CVNMapper::~CVNMapper()
  {
    //======================================================================
    // Clean up any memory allocated by your module
    //======================================================================
  }

  //......................................................................
  void CVNMapper::beginJob()
  {  }

  //......................................................................
  void CVNMapper::endJob()
  {
  }

  //......................................................................
  void CVNMapper::produce(art::Event& evt)
  {


    art::Handle<std::vector<rb::Cluster> > sliceHandle;
    evt.getByLabel(fClusterLabel,sliceHandle);

    if(sliceHandle->empty()){
      mf::LogWarning ("No Slices")<<"No Slices in the input file";
      return;
    }

    art::PtrVector<rb::Cluster>  sliceCol;
    for(unsigned int i = 0; i<sliceHandle->size();++i){
      art::Ptr<rb::Cluster> clust(sliceHandle,i);
      sliceCol.push_back(clust);
    }


    //Declaring containers for things to be stored in event
    std::unique_ptr< std::vector<PixelMap> >
                                  pmCol(new std::vector<PixelMap>);
    std::unique_ptr< std::vector<PixelMap> >
                                  prong_pmCol(new std::vector<PixelMap>);
    std::unique_ptr< art::Assns<PixelMap, rb::Cluster> >
                                  assoc(new art::Assns<PixelMap, rb::Cluster>);
    std::unique_ptr< art::Assns<PixelMap, rb::Prong> >
                                  prong_assoc(new art::Assns<PixelMap,
                                              rb::Prong>);



    for(unsigned int iSlice = 0; iSlice < sliceCol.size(); ++iSlice)
    {
      if (sliceCol[iSlice]->IsNoise() ||
          sliceCol[iSlice]->NCell() < fMinClusterHits)
        continue;
      // Skip if we're obeying preselection
      if(fObeyPreselection && rb::IsFiltered(evt, sliceHandle,iSlice))
        continue;

      PixelMap pm = fProducer.CreateMap(*sliceCol[iSlice]);
      Boundary bound = pm.Bound();

      pmCol->push_back(pm);
      util::CreateAssn(*this, evt, *(pmCol.get()),
                       sliceCol[iSlice], *(assoc.get()),  UINT_MAX,
                       fClusterPMLabel);

      // Option to save prong level pixel maps
      if ( fMapProngs ){

	art::FindManyP<rb::Prong> fmProng3D(sliceHandle, evt,
                              art::InputTag(fProngModLabel, fProng3DLabel));
	art::FindManyP<rb::Prong> fmProng2D(sliceHandle, evt,
                              art::InputTag(fProngModLabel, fProng2DLabel));

	std::vector<art::Ptr<rb::Prong>> prongs3D;
	std::vector<art::Ptr<rb::Prong>> prongs2D;

	if( fmProng2D.isValid() ) prongs2D = fmProng2D.at(iSlice);
	if( fmProng3D.isValid() ) prongs3D = fmProng3D.at(iSlice);
	else continue;

	for( unsigned int iProng = 0; iProng < prongs3D.size(); ++iProng ){

	  // make prong maps with the same boundary as the slice maps
	  PixelMap new_pm = fProducer.CreateMapGivenBoundary(*prongs3D[iProng],
                                                             bound);

	  prong_pmCol->push_back(new_pm);
	  util::CreateAssn(*this, evt, *(prong_pmCol.get()),
			   prongs3D[iProng], *(prong_assoc.get()), UINT_MAX, fProngPMLabel);
	}// 3D prongs

	for( unsigned int iProng2 = 0; iProng2 < prongs2D.size(); ++iProng2 ){

	  // make prong maps with the same boundary as the slice maps
	  PixelMap new_pm = fProducer.CreateMapGivenBoundary(*prongs2D[iProng2],
                                                       bound);

	  prong_pmCol->push_back(new_pm);
	  util::CreateAssn(*this, evt, *(prong_pmCol.get()),
			   prongs2D[iProng2], *(prong_assoc.get()), UINT_MAX, fProngPMLabel);
	}// 2D prongs

      }// MapProngs

    }
    evt.put(std::move(pmCol), fClusterPMLabel);
    evt.put(std::move(prong_pmCol), fProngPMLabel);
    evt.put(std::move(assoc));
    evt.put(std::move(prong_assoc));
    //    evt.put(std::move(prong_assoc),fProng3DLabel);

  }

  //----------------------------------------------------------------------



DEFINE_ART_MODULE(cvn::CVNMapper);
} // end namespace cvn
////////////////////////////////////////////////////////////////////////







