////////////////////////////////////////////////////////////////////////
// \file    CVNProngEvaluator_module.cc
// \brief   Producer module creating prong CVN neural net results
// \author  Evan Niner - edniner@fnal.gov
////////////////////////////////////////////////////////////////////////

// C/C++ includes
#include <iostream>
#include <sstream>

// ROOT includes
#include "TTree.h"
#include "TH2F.h"

// Framework includes
#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Services/Optional/TFileDirectory.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Framework/Services/Registry/ServiceHandle.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "art/Framework/Core/FindManyP.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Persistency/Common/Assns.h"

// NOvASoft includes
#include "RecoBase/PID.h"
#include "RecoBase/Cluster.h"
#include "RecoBase/FilterList.h"
#include "Utilities/AssociationUtil.h"


#include "CVN/func/PixelMap.h"
#include "CVN/func/Result.h"
#include "CVN/art/CaffeNetHandler.h"
#include "CVN/func/InteractionType.h"
#include "CVN/func/AssignLabels.h"
#include "CVN/func/TrainingData.h"
#include "CVN/func/InteractionType.h"
#include "CVN/func/EventLabeledPMaps.h"
#include "CVN/func/ProngType.h"
#include "CVN/func/ProngTrainingData.h"




namespace cvn {

  class CVNProngEvaluator : public art::EDProducer {
  public:
    explicit CVNProngEvaluator(fhicl::ParameterSet const& pset);
    ~CVNProngEvaluator();

    void produce(art::Event& evt);
    void beginJob();
    void endJob();



  private:
    /// Module lablel for input clusters
    std::string    fClusterLabel;

    /// Module label for input pixel maps
    std::string fPixelMapInput;
    /// Module lablel for input prongs
    std::string    fProngModLabel;
    /// Instance lablel for input 3D prongs
    std::string    fProng3DLabel;

    ///  Check rb::IsFiltered?
    bool        fObeyPreselection;
    bool        fProngOnly;


    //
    cvn::CaffeNetHandler fHandler;

    /// Number of outputs fron neural net
    unsigned int fNOutput;

  };



  //.......................................................................
  CVNProngEvaluator::CVNProngEvaluator(fhicl::ParameterSet const& pset):
  fClusterLabel  (pset.get<std::string>         ("ClusterLabel")),
  fPixelMapInput (pset.get<std::string>         ("PixelMapInput")),
  fProngModLabel (pset.get<std::string>         ("ProngModLabel")),
  fProng3DLabel  (pset.get<std::string>         ("Prong3DLabel")),
  fObeyPreselection (pset.get<bool>             ("ObeyPreselection")),
  fProngOnly     (pset.get<bool>                ("ProngOnly")),
  fHandler       (pset.get<fhicl::ParameterSet> ("CaffeNetHandler")),
  fNOutput       (fHandler.NOutput())
  {
    produces< std::vector<cvn::Result>   >();
    produces< art::Assns<cvn::Result, rb::Cluster> >();
    produces< art::Assns<cvn::Result, rb::Prong> >();
    produces< std::vector<rb::PID>       >();
    produces< art::Assns<rb::PID,     rb::Prong> >();
  }

  //......................................................................
  CVNProngEvaluator::~CVNProngEvaluator()
  {
    //======================================================================
    // Clean up any memory allocated by your module
    //======================================================================
  }

  //......................................................................
  void CVNProngEvaluator::beginJob()
  {  }

  //......................................................................
  void CVNProngEvaluator::endJob()
  {
  }

  //......................................................................
  void CVNProngEvaluator::produce(art::Event& evt)
  {

    /// Define containers for the things we're going to produce
    std::unique_ptr< std::vector<Result> >
                                  resultCol(new std::vector<Result>);
    std::unique_ptr< std::vector<rb::PID> >
                                  pidCol(new std::vector<rb::PID>);
    std::unique_ptr< art::Assns<Result, rb::Cluster> >
                                  assoc(new art::Assns<Result, rb::Cluster>);
    std::unique_ptr< art::Assns<Result, rb::Prong> >
                                  assocp(new art::Assns<Result, rb::Prong>);
    std::unique_ptr< art::Assns<rb::PID, rb::Prong> >
      assocpid(new art::Assns<rb::PID, rb::Prong>);


    // get the slices
    art::Handle< std::vector< rb::Cluster > > clusterHandle;
    evt.getByLabel(fClusterLabel, clusterHandle);
    const std::vector<rb::Cluster> & clusters = *clusterHandle;


    art::PtrVector<rb::Cluster>  sliceCol;
    for(unsigned int i = 0; i<clusterHandle->size();++i){
      art::Ptr<rb::Cluster> clust(clusterHandle,i);
      sliceCol.push_back(clust);
    }


    art::FindManyP<PixelMap> fmPixelMap(clusterHandle, evt, fPixelMapInput);


    for(size_t iClust = 0; iClust < clusters.size(); ++iClust) {

      if(!fmPixelMap.isValid()) continue;
      if(fObeyPreselection && rb::IsFiltered(evt,clusterHandle,iClust))
        continue;


      const std::vector<art::Ptr<PixelMap> > pixelMaps = fmPixelMap.at(iClust);

      if(pixelMaps.empty()) continue;

      art::FindManyP<rb::Prong> fmProng3D(clusterHandle, evt, art::InputTag(fProngModLabel, fProng3DLabel));	
      std::vector<art::Ptr<rb::Prong>> prongs3D;	
      if( fmProng3D.isValid() ) prongs3D = fmProng3D.at(iClust);	
      art::FindOneP<PixelMap> foPixelMap3D(prongs3D, evt, fPixelMapInput);
      for( unsigned int iProng = 0; iProng < prongs3D.size(); ++iProng ){	
        cet::maybe_ref<art::Ptr<PixelMap> const> rpm(foPixelMap3D.at(iProng));
        art::Ptr<PixelMap> pm = rpm.ref();
        if (pm){
          const float* output;
          if (fProngOnly){
	    std::pair<const float*, const float*> pairedoutput= fHandler.Predict(*pm);
	    output=pairedoutput.first;
            resultCol->emplace_back(output, fNOutput);
          }
          else{
            output = fHandler.PredictSP(*pixelMaps[0], *pm);
            resultCol->emplace_back(output, fNOutput);
          }

	  // Output object with PDGs rather than version dependednt cvn ID
	  std::vector<std::pair<int, double>> outputwithpdg;

	  std::cout<<" pdg-----------------------"<<std::endl;
	  for ( unsigned int j = 0; j < fNOutput; ++j ){

	    outputwithpdg.push_back(std::make_pair(GetPDGByPType((cvn::PType)j), (double)output[j]));

	    pidCol->emplace_back(outputwithpdg[j].first, outputwithpdg[j].second);

	    util::CreateAssn(*this, evt, *(pidCol.get()),
	    		     prongs3D[iProng], *(assocpid.get()),  UINT_MAX);
	    std::cout<<" pdg = "<<outputwithpdg[j].first<<"  cvnScore = "<<outputwithpdg[j].second<<std::endl;
	  }

          util::CreateAssn(*this, evt, *(resultCol.get()),
                           sliceCol[iClust], *(assoc.get()),  UINT_MAX);
          util::CreateAssn(*this, evt, *(resultCol.get()),
                           prongs3D[iProng], *(assocp.get()),  UINT_MAX);
        }
      }
    }

    evt.put(std::move(pidCol));
    evt.put(std::move(resultCol));
    evt.put(std::move(assoc));
    evt.put(std::move(assocp));
    evt.put(std::move(assocpid));


  }

  //----------------------------------------------------------------------



DEFINE_ART_MODULE(cvn::CVNProngEvaluator);
} // end namespace cvn
////////////////////////////////////////////////////////////////////////







