#include "art/Framework/Services/Registry/ServiceHandle.h"

#include "CVN/func/AssignLabels.h"
#include "CVN/func/InteractionType.h"
#include "CVN/func/TrainingData.h"
#include "CVN/func/ProngType.h"
#include "CVN/func/HitType.h"
#include "MCCheater/BackTracker.h"

#include "RecoBase/Cluster.h"
#include "SimulationBase/MCTruth.h"
#include "SimulationBase/MCParticle.h"

#include <iostream>
#include <iomanip>

namespace cvn
{
  /// Get Interaction_t from pdg, mode and iscc.
  /// Setting pdg and mode to zero triggers cosmic ray
  InteractionType GetInteractionType(const simb::MCTruth& truth)
  {

    if(truth.NeutrinoSet())
    {
     int pdg = truth.GetNeutrino().Nu().PdgCode();
     bool iscc = truth.GetNeutrino().CCNC() == simb::kCC;
     int trueMode = truth.GetNeutrino().Mode();

     if(iscc)
     {
       if(abs(pdg) == 14)
       {
        switch(trueMode){
          case simb::kQE: return kNumuQE; break;
          case simb::kRes: return kNumuRes; break;
          case simb::kDIS: return kNumuDIS; break;
          default: return kNumuOther;
        }
      }
      else if(abs(pdg) == 12)
      {
        switch(trueMode){
          case simb::kQE: return kNueQE; break;
          case simb::kRes: return kNueRes; break;
          case simb::kDIS: return kNueDIS; break;
          default: return kNueOther;
        }
      }
      else if(abs(pdg) == 16)
      {
        switch(trueMode){
          case simb::kQE: return kNutauQE; break;
          case simb::kRes: return kNutauRes; break;
          case simb::kDIS: return kNutauDIS; break;
          default: return kNutauOther;
        }
      }
    }
    else if(trueMode==simb::kNuElectronElastic){
     return kNuElectronElastic;
   }
   else return kNC;
 }
 else return kCosmic;

 return kOther;
}

InteractionType GetInteractionTypeFromSlice(int pdg, bool iscc, int trueMode)
{

  if(iscc){

    if(abs(pdg) == 14){
      switch(trueMode){
        case simb::kQE: return kNumuQE; break;
        case simb::kRes: return kNumuRes; break;
        case simb::kDIS: return kNumuDIS; break;
        default: return kNumuOther;
      }
    }
    else if(abs(pdg) == 12){
      switch(trueMode){
        case simb::kQE: return kNueQE; break;
        case simb::kRes: return kNueRes; break;
        case simb::kDIS: return kNueDIS; break;
        default: return kNueOther;
      }
    }
    else if(abs(pdg) == 16){
      switch(trueMode){
        case simb::kQE: return kNutauQE; break;
        case simb::kRes: return kNutauRes; break;
        case simb::kDIS: return kNutauDIS; break;
        default: return kNutauOther;
      }
    }

  }
  else if(trueMode==simb::kNuElectronElastic){
    return kNuElectronElastic;
  }
  else return kNC;

  return kOther;
}

  InteractionType SliceClassify(const art::Ptr<simb::MCTruth> truth,
				const rb::Cluster& slice,
				float& nuEnergy, float& lepEnergy){

  std::cout<<"Slice NCells  =  "<<slice.NCell()<<std::endl;

  if(!truth->NeutrinoSet()) return kOther;

    // get nu energy
  const simb::MCNeutrino& nu = truth->GetNeutrino();
  int  nuPDG       = nu.Nu().PdgCode();
  bool nuIsCC      = nu.CCNC() == simb::kCC;
  int  trueMode    = nu.Mode();

  InteractionType sType = kOther;

  sType = GetInteractionTypeFromSlice(nuPDG, nuIsCC, trueMode);

  nuEnergy = nu.Nu().E();
  lepEnergy = nu.Lepton().E();
  return sType;
}

//.............................................................................
HitType GetHitTypeByPDG(int pdg)
{
  switch (pdg) {
    case  11:
    case -11:
    return kElectronHit;
    case  13:
    case -13:
    return kMuonHit;
    case  2212:
    return kProtonHit;
    case  2112:
    return kNeutronHit;
    case  111:
    return kPiZeroHit;
    case  211:
    case -211:
    return kPionHit;
    case  22:
    return kGammaHit;
    default:
    return kOtherPDGhit;
  }

}//GetHitTypeByPDG

//.............................................................................
HitType HitClassify( art::Ptr< rb::CellHit > Hit, 
		     HitType* hType, double * hPurity)
{

    art::ServiceHandle<cheat::BackTracker> bt;
    std::vector<cheat::TrackIDE>           ParticleTrackIDs;

    *hType = kUnknownHit;
    *hPurity = 0.0;

    // Check the hit is associated to any true particles
    art::PtrVector<rb::CellHit> hit;
    hit.push_back( Hit );
    ParticleTrackIDs  = bt->HitToTrackIDE( Hit );
    if( ParticleTrackIDs.size()  < 1 ) *hType = kEmptyHit;

    if( *hType != kEmptyHit ){
      double totalPur   = 0.0;
      double highestPur = 0.0;
      int highestPurPDG;

      for (unsigned int iID=0; iID < ParticleTrackIDs.size(); ++iID){
       std::set<int> TrackID;
       std::map<int, double> purMap;
       std::map<int, int> parents;

       // Ensure we label it as the highest purity true hit
       int iPartID = ParticleTrackIDs[iID].trackID;
       TrackID.insert(iPartID);
       double iPartPur = bt->HitCollectionPurity(TrackID, hit,
                                                 &purMap, &parents,true);
       if( iPartPur > highestPur ){
         highestPur    = iPartPur;
         highestPurPDG = bt->TrackIDToMotherParticle(iPartID)->PdgCode();
         *hType  = GetHitTypeByPDG(highestPurPDG);
         *hPurity = highestPur;
       }

       totalPur+=iPartPur; //don't need this

      }// for trackIDs 
    }// type != empty
    
    HitType type = *hType;
    
    return type;

}//HitClassify

  // Prongs

ProngType GetTypeByPDG(int pdg)
{

  switch (pdg) {
    case  11:
    case -11:
    return kElectron;
    case  13:
    case -13:
    return kMuon;
    case  2212:
    return kProton;
    case  2112:
    return kNeutron;
    case  111:
    return kPiZero;
    case  211:
    case -211:
    return kPion;
    case  22:
    return kGamma;
    default:
    return kOtherPDG;
  }

  }// GetTypeByInt


  ProngType ProngClassify(const rb::Prong& prong, ProngType* pType3D,
   ProngType* pTypeX, ProngType* pTypeY,
   double* purity3D, double* purityX, double* purityY,
   double* recE, unsigned int* ncellX, unsigned int* ncellY)
  {

    *pType3D = kUnknown;
    *pTypeX  = kUnknown;
    *pTypeY  = kUnknown;

    *purity3D = 0.0;
    *purityX  = 0.0;
    *purityY  = 0.0;
    *purityY  = 0.0;
   
    *ncellX = prong.NXCell();
    *ncellY = prong.NYCell();

    *recE = prong.CalorimetricEnergy();

    if( prong.NXCell() == 0 || 
        prong.NYCell() == 0) *pType3D = kEmpty;
    if( prong.NXCell() == 0 ) *pTypeX  = kEmpty;
    if( prong.NYCell() == 0 ) *pTypeY  = kEmpty;

    art::ServiceHandle<cheat::BackTracker> bt;

    std::vector<cheat::TrackIDE> ParticleTrackIDs, ParticleTrackIDsX,
    ParticleTrackIDsY;

    if( *pType3D != kEmpty )
      ParticleTrackIDs  = bt->HitsToTrackIDE(prong.AllCells());
    if( *pTypeX  != kEmpty )
      ParticleTrackIDsX = bt->HitsToTrackIDE(prong.XCells());
    if( *pTypeY != kEmpty )
      ParticleTrackIDsY = bt->HitsToTrackIDE(prong.YCells());

    if( ParticleTrackIDs.size()  < 1 ) *pType3D = kEmpty;
    if( ParticleTrackIDsX.size() < 1 ) *pTypeX  = kEmpty;
    if( ParticleTrackIDsY.size() < 1 ) *pTypeY  = kEmpty;

    if( *pType3D != kEmpty ){
      double totalPur   = 0.0;
      double highestPur = 0.0;
      //int highestPurID;
      int highestPurPDG;
      for (unsigned int iID=0; iID < ParticleTrackIDs.size(); ++iID){
       std::set<int> TrackID;
       std::map<int, double> purMap;
       std::map<int, int> parents;

       int iPartID = ParticleTrackIDs[iID].trackID;
       TrackID.insert(iPartID);
       double iPartPur = bt->HitCollectionPurity(TrackID, prong.AllCells(),
                                                 &purMap, &parents,true);

       if( iPartPur > highestPur ){
         highestPur    = iPartPur;
	  //highestPurID  = iPartID;
         highestPurPDG = bt->TrackIDToMotherParticle(iPartID)->PdgCode();
         *pType3D  = GetTypeByPDG(highestPurPDG);
         *purity3D = highestPur;
       }

       totalPur+=iPartPur;
     }

    }

    if( *pTypeX  != kEmpty ){
      double totalPurX   = 0.0;
      double highestPurX = 0.0;
      //      int highestPurIDX;
      int  highestPurPDGx;
      for (unsigned int ixID=0; ixID < ParticleTrackIDsX.size(); ++ixID){
	std::set<int> TrackID;
	std::map<int, double> purMap;
	std::map<int, int> parents;
	
	int ixPartID = ParticleTrackIDsX[ixID].trackID;
	TrackID.insert(ixPartID);
	double ixPartPur = bt->HitCollectionPurity(TrackID, prong.XCells(),
						   &purMap, &parents,true);
	
	if( ixPartPur > highestPurX ){
	  highestPurX   = ixPartPur;
	  //highestPurIDX = ixPartID;
	  highestPurPDGx = bt->TrackIDToMotherParticle(ixPartID)->PdgCode();
	  *pTypeX  = GetTypeByPDG(highestPurPDGx);
	  *purityX = highestPurX;
	}
	
	totalPurX+=ixPartPur;
      }
      
    }
    if( *pTypeY != kEmpty ){
      double totalPurY   = 0.0;
      double highestPurY = 0.0;
      //      int highestPurIDY;
      int highestPurPDGy;
      for (unsigned int iyID=0; iyID < ParticleTrackIDsY.size(); ++iyID){
	std::set<int> TrackID;
	std::map<int, double> purMap;
	std::map<int, int> parents;
	
	int iyPartID = ParticleTrackIDsY[iyID].trackID;
	TrackID.insert(iyPartID);
	double iyPartPur = bt->HitCollectionPurity(TrackID, prong.YCells(), &purMap,
						   &parents,true);
	
	if( iyPartPur > highestPurY ){
	  highestPurY   = iyPartPur;
	  //highestPurIDY = iyPartID;
	  highestPurPDGy = bt->TrackIDToMotherParticle(iyPartID)->PdgCode();
	  *pTypeY = GetTypeByPDG(highestPurPDGy);
	  *purityY = highestPurY;
	}
	
	totalPurY+=iyPartPur;
      }
      
    }
    
    ProngType pType;
    
    pType = *pType3D;
    
    return pType;
  }// ProngClassify.

  std::vector< std::pair<int, double> > GetProngPurityByPDG(const rb::Prong& prong, 
							    ProngType* pType3D,
							    double* purity3D)
  {

    std::vector< std::pair<int, double> > puritybypdg;
    *pType3D = kUnknown;
    *purity3D = 0.0;

    if( prong.NXCell() == 0 || 
        prong.NYCell() == 0) *pType3D = kEmpty;

    art::ServiceHandle<cheat::BackTracker> bt;

    std::vector<cheat::TrackIDE> ParticleTrackIDs;

    if( *pType3D != kEmpty )
      ParticleTrackIDs  = bt->HitsToTrackIDE(prong.AllCells());

    if( ParticleTrackIDs.size()  < 1 ) *pType3D = kEmpty;

    if( *pType3D != kEmpty ){

      double highestPur = 0.0;
      int highestPurPDG = 0;

      for (unsigned int iID=0; iID < ParticleTrackIDs.size(); ++iID){
	std::set<int> TrackID;
	std::map<int, double> purMap;
	std::map<int, int> parents;
	
	int iPartID = ParticleTrackIDs[iID].trackID;
	TrackID.insert(iPartID);
	int iPartPDG = bt->TrackIDToMotherParticle(iPartID)->PdgCode();
	double iPartPur = bt->HitCollectionPurity(TrackID, prong.AllCells(),
						  &purMap, &parents,true);
	puritybypdg.push_back(std::make_pair(iPartPDG, iPartPur));

	if( iPartPur > highestPur ){
	  highestPur    = iPartPur;
	  highestPurPDG = bt->TrackIDToMotherParticle(iPartID)->PdgCode();
	  *pType3D  = GetTypeByPDG(highestPurPDG);
	  *purity3D = highestPur;
	}
	
      }
      
    }
    
    return puritybypdg;
  }// ProngPurityByPDG


}
