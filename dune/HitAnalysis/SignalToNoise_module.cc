////////////////////////////////////////////////////////////////////////
// Class:       SignalToNoise
// Module Type: analyzer
// File:        SignalToNoise_module.cc
//
// Generated at Sat Sep 10 22:01:34 2016 by Tingjun Yang using artmod
// from cetpkgsupport v1_10_02.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h" 
#include "canvas/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"
#include "lardataobj/RecoBase/Track.h"
#include "lardataobj/RawData/ExternalTrigger.h"
#include "lardataobj/RawData/RawDigit.h"
#include "lardataobj/RecoBase/TrackHitMeta.h"
#include "lardataobj/RecoBase/Hit.h"
#include "lardata/Utilities/AssociationUtil.h"
#include "lardata/RecoBaseArt/TrackUtils.h"
#include "larcore/Geometry/Geometry.h"
#include "TH1D.h"
#include "TH2D.h"

#include <vector>

namespace dune {
  class SignalToNoise;
}

class dune::SignalToNoise : public art::EDAnalyzer {
public:
  explicit SignalToNoise(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  SignalToNoise(SignalToNoise const &) = delete;
  SignalToNoise(SignalToNoise &&) = delete;
  SignalToNoise & operator = (SignalToNoise const &) = delete;
  SignalToNoise & operator = (SignalToNoise &&) = delete;

  // Required functions.
  void analyze(art::Event const & e) override;

  // Selected optional functions.
  void beginJob() override;

private:

  // Declare member data here.
  std::string fTrackModuleLabel;
  std::string fExternalCounterModuleLabel;
  std::string fRawDigit0ModuleLabel;
  std::string fRawDigit1ModuleLabel;

  double cx[93], cy[93], cz[93];
  
  TH1D *dcos;
  TH2D *hyz, *hxz;
  TH1D *hsig[8][3][4];
  TH1D *hbkg[8][3][4];
  TH1D *hstb[8][3][4];
};


dune::SignalToNoise::SignalToNoise(fhicl::ParameterSet const & p)
  :
  EDAnalyzer(p),
  fTrackModuleLabel(p.get< std::string >("TrackModuleLabel")),
  fExternalCounterModuleLabel(p.get< std::string >("ExternalCounterModuleLabel")),
  fRawDigit0ModuleLabel("daq"),
  fRawDigit1ModuleLabel("SplitterInput:TPC")
 // More initializers here.
{}

void dune::SignalToNoise::analyze(art::Event const & e)
{
  // Implementation of required member function here.
  // * tracks
  art::Handle< std::vector<recob::Track> > trackListHandle;
  std::vector<art::Ptr<recob::Track> > tracklist;
  if (e.getByLabel(fTrackModuleLabel,trackListHandle))
    art::fill_ptr_vector(tracklist, trackListHandle);


  // * External Counters
  art::Handle< std::vector<raw::ExternalTrigger> > countListHandle;
  std::vector<art::Ptr<raw::ExternalTrigger> > countlist;
  if (e.getByLabel(fExternalCounterModuleLabel,countListHandle))
    art::fill_ptr_vector(countlist, countListHandle);
 
  // * Raw Digits
  art::Handle<std::vector<raw::RawDigit> > rawList0Handle;
  std::vector<art::Ptr<raw::RawDigit> > rawlist0;
  if (e.getByLabel(fRawDigit0ModuleLabel,rawList0Handle))
    art::fill_ptr_vector(rawlist0, rawList0Handle);

  art::Handle<std::vector<raw::RawDigit> > rawList1Handle;
  std::vector<art::Ptr<raw::RawDigit> > rawlist1;
  if (e.getByLabel(fRawDigit1ModuleLabel,rawList1Handle))
    art::fill_ptr_vector(rawlist1, rawList1Handle);

  // * associations
  art::FindManyP<recob::Hit, recob::TrackHitMeta> fmthm(trackListHandle, e, fTrackModuleLabel);

  art::ServiceHandle<geo::Geometry> geom;

  std::vector<int> c1;
  std::vector<int> c2;
  std::vector<int> ci1;
  std::vector<int> ci2;
 
  for (size_t i = 0; i<countlist.size(); ++i){
    for (size_t j = 0; j<countlist.size(); ++j){
      if (i==j) continue;
      if (std::abs(countlist[i]->GetTrigTime()-countlist[j]->GetTrigTime()) < 2){
        if ( (    countlist[i]->GetTrigID() >= 6  && countlist[i]->GetTrigID() <= 15 && countlist[j]->GetTrigID() >= 28 && countlist[j]->GetTrigID() <= 37 ) // East Lower, West Upper 
             || ( countlist[i]->GetTrigID() >= 0  && countlist[i]->GetTrigID() <= 5  && countlist[j]->GetTrigID() >= 22 && countlist[j]->GetTrigID() <= 27 ) // South Lower, North Upper
             || ( countlist[i]->GetTrigID() >= 16 && countlist[i]->GetTrigID() <= 21 && countlist[j]->GetTrigID() >= 38 && countlist[j]->GetTrigID() <= 43 ) // North Lower, South Upper
             ) {
          //              std::cout << "I have a match..."
          //                        << "i " << i << ", ID " << countlist[i]->GetTrigID() << ", time " << countlist[i]->GetTrigTime() << "..."
          //                        << "j " << j << ", ID " << countlist[j]->GetTrigID() << ", Time " <<  countlist[j]->GetTrigTime() 
          //                        << std::endl;
          c1.push_back(countlist[i]->GetTrigID());
          c2.push_back(countlist[j]->GetTrigID());
          ci1.push_back(i);
          ci2.push_back(j);
        }
      }
    }
  }

  if (c1.size()&&tracklist.size()){
    double ccosx = (cx[c1[0]]-cx[c2[0]])/sqrt(pow(cx[c1[0]]-cx[c2[0]],2)+pow(cy[c1[0]]-cy[c2[0]],2)+pow(cz[c1[0]]-cz[c2[0]],2));
    double ccosy = (cy[c1[0]]-cy[c2[0]])/sqrt(pow(cx[c1[0]]-cx[c2[0]],2)+pow(cy[c1[0]]-cy[c2[0]],2)+pow(cz[c1[0]]-cz[c2[0]],2));
    double ccosz = (cz[c1[0]]-cz[c2[0]])/sqrt(pow(cx[c1[0]]-cx[c2[0]],2)+pow(cy[c1[0]]-cy[c2[0]],2)+pow(cz[c1[0]]-cz[c2[0]],2));   

    double larStart[3];
    double larEnd[3];
    std::vector<double> trackStart;
    std::vector<double> trackEnd;
 
    for (size_t i = 0; i<tracklist.size(); ++i){
      trackStart.clear();
      trackEnd.clear();
      memset(larStart, 0, 3);
      memset(larEnd, 0, 3);
      tracklist[i]->Extent(trackStart,trackEnd); 
      tracklist[i]->Direction(larStart,larEnd);
      double dc = std::abs(ccosx*larStart[0]+ccosy*larStart[1]+ccosz*larStart[2]);
      dcos->Fill(dc);
      if (dc>0.98){
        double ctime = (countlist[ci1[0]]->GetTrigTime() + countlist[ci2[0]]->GetTrigTime())/(2*32.);        
        for (size_t j = 0; j<tracklist[i]->NumberTrajectoryPoints(); ++j){
          TVector3 loc = tracklist[i]->LocationAtPoint(j);
          hyz->Fill(loc[2],loc[1]);
          if (loc[0]>0){
            hxz->Fill(loc[2],loc[0]-ctime*0.5*0.1085);
          }
          else{
            hxz->Fill(loc[2],loc[0]+ctime*0.5*0.1085);
          }
        }
        if (fmthm.isValid()){
          auto vhit = fmthm.at(i);
          auto vmeta = fmthm.data(i);
          for (size_t h = 0; h < vhit.size(); ++h){
            TVector3 loc = tracklist[i]->LocationAtPoint(vmeta[h]->Index());
            if ((loc[0]>0&&std::abs(loc[0]-ctime*0.5*0.1085)<50)||
                (loc[0]<0&&std::abs(loc[0]+ctime*0.5*0.1085)<50)){
              int besttime = -1;
              for (size_t j = 0; j<rawlist0.size(); ++j){
                if (rawlist0[j]->Channel() == vhit[h]->Channel()){
                  double pedestal = rawlist0[j]->GetPedestal();
                  int maxph = -1;
                  for (size_t k = 0; k<rawlist0[j]->NADC(); ++k){
                    if (float(k)>=vhit[h]->PeakTime()&&float(k)<=vhit[h]->PeakTime()+20){
                      if (int(rawlist0[j]->ADC(k)-pedestal)>maxph){
                        maxph = int(rawlist0[j]->ADC(k)-pedestal);
                        besttime = k;
                      }
                    }
                  }
                  double mean=0;
                  double mean2=0;
                  int npts = 0;
                  for (size_t k = 0; k<rawlist0[j]->NADC(); ++k){
                    if ((int(k)>besttime-200&&int(k)<besttime-100)||
                        (int(k)>besttime+100&&int(k)<besttime+200)){
                      mean += rawlist0[j]->ADC(k)-pedestal;
                      mean2 += pow(rawlist0[j]->ADC(k)-pedestal,2);
                      ++npts;
                    }
                  }
                  mean/=npts;
                  mean2/=npts;
                  double angleToVert = geom->WireAngleToVertical(vhit[h]->View(), vhit[h]->WireID().TPC, vhit[h]->WireID().Cryostat) - 0.5*::util::pi<>();
                  //std::cout<<vhit[h]->View()<<" "<<vhit[h]->WireID().TPC<<" "<<vhit[h]->WireID().Cryostat<<" "<<angleToVert<<std::endl;
                  const TVector3& dir = tracklist[i]->DirectionAtPoint(vmeta[h]->Index());
                  double cosgamma = std::abs(std::sin(angleToVert)*dir.Y() + std::cos(angleToVert)*dir.Z());
                  //std::cout<<maxph*cosgamma<<" "<<sqrt(mean2-mean*mean)<<std::endl;
                  //std::cout<<vhit[h]->PeakTime()<<" "<<vhit[h]->PeakAmplitude()<<" "<<besttime<<" "<<maxph<<std::endl;
                  hsig[vhit[h]->WireID().TPC][vhit[h]->WireID().Plane][0]->Fill(maxph*cosgamma);
                  hbkg[vhit[h]->WireID().TPC][vhit[h]->WireID().Plane][0]->Fill(sqrt(mean2-mean*mean));
                }
              }//loop over rawlist0
              if (besttime<0||besttime>=15000) continue;
              for (size_t j = 0; j<rawlist1.size(); ++j){
                if (rawlist1[j]->Channel() == vhit[h]->Channel()){
                  double pedestal = rawlist1[j]->GetPedestal();
                  int maxph1 = int(rawlist1[j]->ADC(besttime)-pedestal);
                  double mean=0;
                  double mean2=0;
                  int npts = 0;
                  for (size_t k = 0; k<rawlist1[j]->NADC(); ++k){
                    if ((int(k)>besttime-200&&int(k)<besttime-100)||
                        (int(k)>besttime+100&&int(k)<besttime+200)){
                      mean += rawlist1[j]->ADC(k)-pedestal;
                      mean2 += pow(rawlist1[j]->ADC(k)-pedestal,2);
                      ++npts;
                    }
                  }
                  mean/=npts;
                  mean2/=npts;
                  double angleToVert = geom->WireAngleToVertical(vhit[h]->View(), vhit[h]->WireID().TPC, vhit[h]->WireID().Cryostat) - 0.5*::util::pi<>();
                  //std::cout<<vhit[h]->View()<<" "<<vhit[h]->WireID().TPC<<" "<<vhit[h]->WireID().Cryostat<<" "<<angleToVert<<std::endl;
                  const TVector3& dir = tracklist[i]->DirectionAtPoint(vmeta[h]->Index());
                  double cosgamma = std::abs(std::sin(angleToVert)*dir.Y() + std::cos(angleToVert)*dir.Z());
                  //std::cout<<maxph*cosgamma<<" "<<sqrt(mean2-mean*mean)<<std::endl;
                  //std::cout<<vhit[h]->PeakTime()<<" "<<vhit[h]->PeakAmplitude()<<" "<<besttime<<" "<<maxph<<std::endl;
                  hsig[vhit[h]->WireID().TPC][vhit[h]->WireID().Plane][1]->Fill(maxph1*cosgamma);
                  hbkg[vhit[h]->WireID().TPC][vhit[h]->WireID().Plane][1]->Fill(sqrt(mean2-mean*mean));
                }
              }//loop over rawlist1

            }
          }
        }
      }
    }
  }
}

void dune::SignalToNoise::beginJob()
{
  art::ServiceHandle<art::TFileService> tfs;
  
  dcos = tfs->make<TH1D>("dcos",";cos#theta;",100,0,1.1);
  dcos->Sumw2();

  hxz = tfs->make<TH2D>("hxz",";z (cm);x (cm)",1000,0,160,1000,-50,250);
  hyz = tfs->make<TH2D>("hyz",";z (cm);y (cm)",1000,0,160,1000,-90,120);

  for (int i = 0; i<8; ++i){
    for (int j = 0; j<3; ++j){
      for (int k = 0; k<4; ++k){
        hsig[i][j][k]= tfs->make<TH1D>(Form("hsig_%d_%d_%d",i,j,k),Form("TPC=%d, Plane=%d, %d",i,j,k), 200,0,200);
        hbkg[i][j][k]= tfs->make<TH1D>(Form("hbkg_%d_%d_%d",i,j,k),Form("TPC=%d, Plane=%d, %d",i,j,k), 100,0,100);
        hstb[i][j][k]= tfs->make<TH1D>(Form("hstb_%d_%d_%d",i,j,k),Form("TPC=%d, Plane=%d, %d",i,j,k), 100,0,100);
      }
    }
  }
        
                           

  std::ifstream in;
  in.open("/dune/app/users/mthiesse/olddev/CounterZOffset/work/counterInformation.txt");
  char line[1024];
  while(1){
    in.getline(line,1024);
    if (!in.good()) break;
    int i;
    float x,y,z;
    sscanf(line,"%d %f %f %f",&i,&x,&y,&z);
    //cout<<i<<" "<<x<<" "<<y<<" "<<z<<endl;
    cx[i] = x;
    cy[i] = y;
    cz[i] = z;
  }
  in.close();

}

DEFINE_ART_MODULE(dune::SignalToNoise)
