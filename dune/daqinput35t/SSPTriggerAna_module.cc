// -*- mode: c++; c-basic-offset: 2; -*-
////////////////////////////////////////////////////////////////////////
// Class:       SSPTriggerAna
// Module Type: producer
// File:        SSPTriggerAna_module.cc
//
// Quickly analyze raw data trigger rate in the SSP
//
// Alex Himmel ahimmel@fnal.gov
//
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDAnalyzer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <iostream>
#include <map>
#include <set>
#include <iomanip>

//lbne-artdaq includes
#include "lbne-raw-data/Overlays/SSPFragment.hh"
#include "lbne-raw-data/Overlays/anlTypes.hh"
#include "artdaq-core/Data/Fragments.hh"

//larsoft includes
#include "lardata/RawData/raw.h"
#include "lardata/RawData/OpDetWaveform.h"
#include "larcore/Geometry/Geometry.h"

//daqinput35t includes

#include "utilities/UnpackFragment.h"
#include "SSPFragmentToOpDetWaveform.h"

namespace DAQToOffline {
  class SSPTriggerAna;
}

class DAQToOffline::SSPTriggerAna : public art::EDAnalyzer {
public:
  explicit SSPTriggerAna(fhicl::ParameterSet const & pset);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.
  
  void analyze(art::Event const & evt);
  void reconfigure(fhicl::ParameterSet const& pset);
  void printParameterSet();


   // Plugins should not be copied or assigned.
  SSPTriggerAna(SSPTriggerAna const &) = delete;
  SSPTriggerAna(SSPTriggerAna &&) = delete;
  SSPTriggerAna & operator = (SSPTriggerAna const &) = delete;
  SSPTriggerAna & operator = (SSPTriggerAna &&) = delete;
 
private:
  void beginJob() override;
  void endJob  () override;
  void beginEvent(art::EventNumber_t eventNumber);
  void endEvent  (art::EventNumber_t eventNumber);

  std::string fFragType;
  std::string fRawDataLabel;
  std::string fOutputDataLabel;
  double      fNOvAClockFrequency; //MHz
  std::string fChannelMapFile;
  
  std::map<int,int> theChannelMap;

  unsigned long int firstTime;
  unsigned long int lastTime;
  std::map<int, long int> triggerCount;
};


DAQToOffline::SSPTriggerAna::SSPTriggerAna(fhicl::ParameterSet const & pset) : art::EDAnalyzer(pset)
{

  this->reconfigure(pset);

  //first_FirstSample = -1;
  //first_TimeStamp = -1;
}

void DAQToOffline::SSPTriggerAna::reconfigure(fhicl::ParameterSet const& pset){

  fFragType           = pset.get<std::string>("FragType");
  fRawDataLabel       = pset.get<std::string>("RawDataLabel");
  fNOvAClockFrequency = pset.get<double>("NOvAClockFrequency"); // in MHz
  fChannelMapFile     = pset.get<std::string>("OpDetChannelMapFile");

  //fDebug = pset.get<bool>("Debug");
  //fZeroThreshold=0;
  //fCompression=raw::kNone;

  printParameterSet();
  BuildOpDetChannelMap(fChannelMapFile, theChannelMap);
  
}

void DAQToOffline::SSPTriggerAna::printParameterSet(){

  mf::LogDebug("SSPTriggerAna") << "===================================="   << "\n"
			       << "Parameter Set"                          << "\n"
			       << "===================================="   << "\n"
			       << "fFragType:        " << fFragType        << "\n"
			       << "fRawDataLabel:    " << fRawDataLabel    << "\n"
			       << "fChannelMapFile:  " << fChannelMapFile  << "\n"
			       << "===================================="   << "\n";
}

void DAQToOffline::SSPTriggerAna::beginJob()
{
  //art::ServiceHandle<art::TFileService> tfs;
  //adc_values_ = tfs->make<TH1D>("adc_values","adc_values",4096,-0.5,4095.5);

  firstTime = (((unsigned long int)1)<<63);
  lastTime = 0;
}

void DAQToOffline::SSPTriggerAna::beginEvent(art::EventNumber_t /*eventNumber*/)
{
  //reset ADC histogram
  //adc_values_->Reset();
  //reset counters
  //n_adc_counter_  = 0;
  //adc_cumulative_ = 0;
}

void DAQToOffline::SSPTriggerAna::endEvent(art::EventNumber_t eventNumber)
{
  //write the ADC histogram for the given event
  //if(n_adc_counter_)
    //  adc_values_->Write(Form("adc_values:event_%d", eventNumber));
}

void DAQToOffline::SSPTriggerAna::endJob()
{
  //delete adc_values_;

  
  long int deltaT = lastTime-firstTime;
  double deltaTus =  ((double)deltaT)/fNOvAClockFrequency;


  mf::LogVerbatim("SSPTriggerAna") << "!! Trigger Rate Report." << std::endl;
  mf::LogVerbatim("SSPTriggerAna") << "!! Time: " << deltaTus / 60.e6 << " minutes." << std::endl;

  for (auto itr = triggerCount.begin(); itr != triggerCount.end(); itr++) {
    double freq = ((double)itr->second) / deltaTus * 1000.;
    mf::LogVerbatim("SSPTriggerAna") << "!!    Channel " << std::setw(3) << itr->first << ": " << freq << " kHz" << std::endl;
  }
  
  
  /*
  mf::LogInfo("SSPTriggerAna") << "firstSample:  " << firstTime << " samples\n"
                               << "lastSample:   " << lastTime  << " samples\n"
                               << "totalSamples: " << deltaT    << " samples\n"
                               << "totalTime:    " << deltaTus  << " us\n"
                               << "# Channels:   " << channels.size() << "\n"
                               << "# Triggers:   " << triggerCount << "\n"
                               << "Frequency:    " << freq << "kHz\n";
  */
}



void DAQToOffline::SSPTriggerAna::analyze(art::Event const & evt)
{

  art::Handle<artdaq::Fragments> rawFragments;
  evt.getByLabel(fRawDataLabel, fFragType, rawFragments);

  // Check if there is SSP data in this event
  // Don't crash code if not present, just don't save anything
  try { rawFragments->size(); }
  catch(std::exception e) {
    mf::LogWarning("SSPTriggerAna") << "WARNING: Raw SSP data not found in event " << evt.event();
    return;
  }

  // Check that the data is valid
  if(!rawFragments.isValid()){
    mf::LogError("SSPTriggerAna") << "Run: " << evt.run()
				 << ", SubRun: " << evt.subRun()
				 << ", Event: " << evt.event()
				 << " is NOT VALID";
    throw cet::exception("raw NOT VALID");
    return;
  }



  unsigned int numFragments = rawFragments->size();

  for (size_t idx = 0; idx < numFragments; ++idx) {
    const auto& frag((*rawFragments)[idx]);
    lbne::SSPFragment sspf(frag);

    unsigned int nTriggers = CheckAndGetNTriggers(frag, sspf);
      
    const unsigned int* dataPointer = sspf.dataBegin();

        
    for (unsigned int triggersProcessed = 0;
         (nTriggers==0 || triggersProcessed < nTriggers) && dataPointer < sspf.dataEnd();
         ++triggersProcessed) {
      
      //
      // The elements of the OpDet Pulse
      //
      unsigned short     OpChannel = -1;       ///< Derived Optical channel
      unsigned long      FirstSample = 0;      ///< first sample time in ticks
        

      // Load the event header, advance the pointer
      const SSPDAQ::EventHeader* daqHeader=reinterpret_cast<const SSPDAQ::EventHeader*>(dataPointer);
      dataPointer += sizeof(SSPDAQ::EventHeader)/sizeof(unsigned int);

      // Get ADC Count, create pointer to adcs
      unsigned int nADC=(daqHeader->length-sizeof(SSPDAQ::EventHeader)/sizeof(unsigned int))*2;

      //get the information from the header
      try {
        OpChannel = GetOpChannel(daqHeader, theChannelMap);

        FirstSample = GetGlobalFirstSample(daqHeader);
        //TimeStamp = ((double)FirstSample)/fNOvAClockFrequency;

        if (FirstSample < 1e16) {
          PrintHeaderInfo(daqHeader, fNOvAClockFrequency);
          mf::LogInfo("SSPTriggerAna") << "Problem timestamp at " << FirstSample << std::endl;
          continue;
        }
      }
      catch (cet::exception e) {
        continue;
      }

      firstTime = std::min(firstTime, FirstSample);
      lastTime  = std::max(lastTime,  FirstSample);
      triggerCount[OpChannel]++;
      
      // Advance the dataPointer to the next header
      dataPointer+=nADC/2;
      
    } // End of loop over triggers
  } // End of loop over fragments (rawFragments)

    
}

DEFINE_ART_MODULE(DAQToOffline::SSPTriggerAna)


