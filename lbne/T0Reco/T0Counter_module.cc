////////////////////////////////////////////////////////////////////////
// Class:       T0Counter
// Module Type: producer
// File:        T0Counter_module.cc
//
// Generated at Tue Mar 24 08:49:12 2015 by Matthew Thiesse using artmod
// from cetpkgsupport v1_08_04.
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Framework/Services/Optional/TFileService.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include "RawData/ExternalTrigger.h"
#include "AnalysisBase/T0.h"
#include "RecoBase/Track.h"
#include "Utilities/DetectorProperties.h"
#include "Utilities/TimeService.h"
#include "Utilities/AssociationUtil.h"
#include "Geometry/AuxDetGeo.h"
#include "Geometry/Geometry.h"

#include <memory>
#include <map>

#include "TTree.h"
#include "TVector3.h"

namespace lbne {
  class T0Counter;
}

class lbne::T0Counter : public art::EDProducer {
public:
  explicit T0Counter(fhicl::ParameterSet const & p);
  // The destructor generated by the compiler is fine for classes
  // without bare pointers or other resource use.

  // Plugins should not be copied or assigned.
  T0Counter(T0Counter const &) = delete;
  T0Counter(T0Counter &&) = delete;
  T0Counter & operator = (T0Counter const &) = delete;
  T0Counter & operator = (T0Counter &&) = delete;

  // Required functions.
  void produce(art::Event & e) override;

  // Selected optional functions.
  void beginJob() override;
  void endJob() override;

private:

  art::ServiceHandle<util::TimeService> fTimeService;
  art::ServiceHandle<util::DetectorProperties> fDetProp;
  art::ServiceHandle<geo::Geometry> fGeom;

  struct t0 {
    std::vector< std::pair< unsigned int, double> > data;

    int multiplicity() { return data.size(); }

    bool testCoincidence(double time, double tol) {// tol is in units of ns
      std::vector<std::pair<unsigned int, double> >::const_iterator it;
      for(it = data.begin(); it != data.end(); ++it) {
	if (time >= (*it).second-tol && time <= (*it).second+tol) return true;
      }
      return false;
    }

    bool testFlatTime() {
      std::vector<std::pair<unsigned int, double> >::const_iterator it;
      for(it = data.begin(); it != data.end(); ++it) {
	std::vector<std::pair<unsigned int, double> >::const_iterator it2;
	for(it2 = data.begin(); it2 != data.end(); ++it2) {
	  if (it != it2 && (*it).first == (*it2).first) return true;
	}
      }
      return false;
    }
    
    double avgTime() {
      double time = 0;
      int num = 0;
      std::vector<std::pair<unsigned int, double> >::const_iterator it;
      for(it = data.begin(); it != data.end(); ++it) {
	time += (*it).second;
	++num;
      }
      if (num != 0) return time/num;
      return -DBL_MAX;
    }

    void insert(double time, unsigned int id) {
      data.push_back(std::pair<unsigned int,double>(id,time));
      return;
    }

    t0(double time, unsigned int id) {
      insert(time,id);
    }

    friend bool operator < (t0 const& a, t0 const& b) { return a.avgTime() < b.avgTime(); }
  };

  TVector3 auxDetCenter(unsigned int c);
  TVector3 auxDetNormal(unsigned int c);
  int adjacentCounter(unsigned int c1, unsigned int c2);
  double tick2Time(unsigned int t);

  // fhicl parameters
  std::string fSimCounterModuleLabel;
  std::string fTrackModuleLabel;
  bool fMakeTree;
  double fClockSpeedCounter;
  int fCoincidenceTolerance;
  bool fVerbose;
  double fCombinedTimeDelay;

  double fSampleTimeCounter;
  double fTriggerOffsetTPC;

  // output TTree
  TTree *fTree;
  int run;
  int subrun;
  int event;
  int ntrigs;
  int ntracks;
  unsigned int auxdetid;
  unsigned int tick;
  double time;

};

/////////////////////////////////////////////////////////////////////////////////////

lbne::T0Counter::T0Counter(fhicl::ParameterSet const & p)
  : fSimCounterModuleLabel(p.get<std::string>("SimCounterModuleLabel")),
    fTrackModuleLabel(p.get<std::string>("TrackModuleLabel")),
    fMakeTree(p.get<bool>("MakeTree",false)),
    fClockSpeedCounter(p.get<double>("ClockSpeedCounter")), // MHz
    fCoincidenceTolerance(p.get<int>("CoincidenceTolerance")), // num PENN board ticks
    fVerbose(p.get<bool>("Verbose",true)),
    fCombinedTimeDelay(p.get<double>("CombinedTimeDelay",160)) // ns
{
  fSampleTimeCounter = 1.e3/fClockSpeedCounter;//ns
  fTriggerOffsetTPC = fTimeService->TriggerOffsetTPC()*1.e3; // ns

  //produces< std::vector< anab::T0 > >();
  //produces< art::Assns< anab::T0, raw::ExternalTrigger> >();
  //produces< art::Assns< anab::T0, recob::Track> >();
}

/////////////////////////////////////////////////////////////////////////////////////

void lbne::T0Counter::produce(art::Event & e)
{
  // make collection of T0 objects
  std::unique_ptr< std::vector< anab::T0> > t0col(new std::vector<anab::T0>);

  run = e.run();
  subrun = e.subRun();
  event = e.id().event();
  
  art::Handle< std::vector< raw::ExternalTrigger> > externalTriggerListHandle;
  e.getByLabel(fSimCounterModuleLabel, externalTriggerListHandle);
  std::vector< art::Ptr< raw::ExternalTrigger> > trigs;
  art::fil_ptr_vector(trigs,externalTriggerListHandle);

  ntrigs = externalTriggerListHandle->size();

  //art::Handle< std::vector< recob::Track> > trackListHandle;
  //e.getByLabel(fTrackModuleLabel, trackListHandle);
  //ntracks = trackListHandle->size();

  std::map<t0, std::vector< art::Ptr<raw::ExternalTrigger> > > t0TrigMap;

  // fill the first step of t0 finding (find nearby hits)
  for (auto const& trig : trigs) {
    auxdetid = trig->GetTrigID();
    tick = trig->GetTrigTime();
    time = tick2Time(tick);
    if (fMakeTree) fTree->Fill();
    
    double tol = fCoincidenceTolerance*fSampleTimeCounter;
    std::vector<t0>::iterator t0it;
    for (t0it = t0v.begin(); t0it != t0v.end(); ++t0it) {
      t0* t = &(*t0it);
      if (t->testCoincidence(time,tol)) {
	t->insert(time,auxdetid);
	break;
      }
    }
    if (t0it == t0v.end()) {
      t0v.push_back(t0(time,auxdetid));
    }
  }

  // flatten data in time:
  // if there are hits on the same counters but at different times,
  // combine to get one counter hit at the average time.
  // goddamn i hope this is the right thing to do, took long enough to code...
  // not even sure it is "stable", but i know it's definitely not optimised for speed!
  std::vector<std::pair<unsigned int, double> > data;
  std::vector<t0>::iterator t0it;
  int t0id=0;
  for(t0it = t0v.begin(); t0it != t0v.end(); ++t0it,++t0id) {
    t0* t = &(*t0it);
    data = t->data;
    
    // test if t0 object needs flattening
    bool q = t->testFlatTime();
    if (fVerbose) mf::LogVerbatim("T0Counter") << "\n T0 number " << t0id << " needs flattening in time: " << ((q) ? "true" : "false");
    if (!q) continue;

    // print information, if interested
    if (fVerbose) {
      mf::LogVerbatim("T0Counter") << "Before flattening in time ===> T0 number " << t0id << ":";
      for (size_t it = 0; it < data.size(); ++it) {
	unsigned int id = data[it].first;
	double t = data[it].second;
	mf::LogVerbatim("T0Counter") << std::fixed << std::setprecision(1) << "                   Time: " << t << "  ID: " << id;
      }
    }

    //
    // do flattening
    //
    // loop over t0 data
    for (size_t it = 0; it < data.size(); ) {
      unsigned int id = data[it].first;

      if (fVerbose) mf::LogVerbatim("T0Counter") << "Testing it=" << it << "  id=" << id;

      // make vector of indices of data which contain identical ID info and different time info
      std::vector<size_t> same;
      double avgtime = 0;
      bool foundduplicate = false;

      // loop over t0 data again to find duplicates
      for(size_t it2 = 0; it2 < data.size(); ++it2) {
	unsigned int id2 = data[it2].first;
	
	// look for duplicate IDs, will also find the SAME entry in data
	if (id2 == id) {
	  // push back the index corresponding to identical IDs, do not enter the same index more than once
	  same.push_back(it2);
	  //if (std::count(same.begin(),same.end(),it2)==0) same.push_back(it2);
	  // calculate average time of duplicate hits, first add all times
	  avgtime+=data[it2].second;
	  // if found a duplicate, set the flag
	  if (it != it2) foundduplicate = true;
	}
      }
      // if found more than one of the same ID, skip the erase/push_back stuff
      // and iterate along data
      if (!foundduplicate) {
	++it;
	continue;
      }
      
      // calculate the average time of hits
      avgtime/=same.size();

      // erase all duplicate entries
      // the index of the erased entry is adjusted by i because, as they are being deleted, data gets smaller, and all of the indices get shifted down by 1 for every erased entry.
      for (size_t i = 0; i < same.size(); ++i) {
	data.erase(data.begin()+same[i]-i);
      }
      
      // insert new data point at the average time to the BACK of the data vector. 
      // so the enclosing for loop should not be iterated, otherwise the new it'th 
      // element will be skipped.
      data.push_back(std::pair<unsigned int, double>(id,avgtime));

      if (fVerbose) {
	mf::LogVerbatim("T0Counter") << "Intermediary Step " << it << " ===> T0 number " << t0id << ":";
	for (size_t i = 0; i < data.size(); ++i) {
	  unsigned int id = data[i].first;
	  double t = data[i].second;
	  mf::LogVerbatim("T0Counter") << std::fixed << std::setprecision(1) << "                   Time: " << t << "  ID: " << id;
	}
      }
    }

    // print results of flattening, if interested
    if (fVerbose) {
      mf::LogVerbatim("T0Counter") << "After flattening in time ===> T0 number " << t0id << ":";
      for (size_t i = 0; i < data.size(); ++i) {
	unsigned int id = data[i].first;
	double t = data[i].second;
	mf::LogVerbatim("T0Counter") << std::fixed << std::setprecision(1) << "                   Time: " << t << "  ID: " << id;
      }
    }
  }

  

  // flatten hits in planes
  // -- simultaneously, flatten in time DONE
  // get average time and position of auxdets hit (averaged within each plane over similar ticks)
  // filter out useless coincidences
  // calculate test vector between N possible plane hits
  // get recob::Tracks and look for matches


  
  /*
  double avgTick;
  double time;
  int multi;
  std::vector<unsigned int> ticks;
  std::vector<unsigned int> ids;
  
  std::vector<t0>::iterator t0it;
  int t0id = 0;
  for (t0it = t0v.begin(); t0it != t0v.end(); ++t0it, ++t0id) {
    if (fVerbose) std::cout << std::endl;
    t0* t = &(*t0it);
    ticks = t->ticks;
    ids = t->ids;
    multi = t->multiplicity();
    if (fVerbose) {
      std::cout << "T0 number " << t0id << " has multiplicity " << multi << "." << std::endl;
      for (size_t i = 0; i < ticks.size(); ++i) {
	std::cout << "       Tick: " << ticks[i] << "  AuxDetID: " << ids[i] << std::endl;
      }
    }

    avgTick=0;
    for (size_t i = 0; i < ticks.size(); ++i) avgTick += ticks[i];
    avgTick *= (1./ticks.size());
    time = tick2Time(avgTick);
    if (fVerbose) std::cout << "Filling T0 with  time=" << time << "  TrigType=0  Bits=" << multi << "  ID=" << t0id << std::endl;
    t0col->push_back(anab::T0(time,
                              0,
                              multi,
                              t0id));

    if (multi < 2) continue; // non-coincidences are difficult to associate with tracks
                             // so, write another module to do this, or do it later

    std::vector<unsigned int> skip;
    int adj = -1;
    int numInPlane = 0;
    double timeAvg = 0;
    TVector3 locAvg(0.,0.,0.);
    for (size_t id1 = 0; id1 < ids.size(); ++id1) {
      if (std::count(skip.begin(),skip.end(),ids[id1]*1000+ticks[id1]) != 0) continue;
      std::vector<unsigned int> idsInPlane;
      idsInPlane.push_back(ids[id1]);
      skip.push_back(ids[id1]*1000+ticks[id1]);
      
      numInPlane = 1;
      timeAvg = ticks[id1];
      locAvg = auxDetCenter(ids[id1]);

      for (size_t id2 = id1+1; id2 < ids.size(); ++id2) {
	adj = adjacentCounter(ids[id1],ids[id2]);
	if (adj != 1 && adj != 2) continue;
	if (std::count(idsInPlane.begin(),idsInPlane.end(),ids[id2]) == 0) {
	  idsInPlane.push_back(ids[id2]);
	  skip.push_back(ids[id2]*1000+ticks[id2]);

	  ++numInPlane;
	  timeAvg += ticks[id2];
	  locAvg += auxDetCenter(id2[id2]);
	}
      }
      std::cout << "plane contains ids ";
      for(size_t i = 0; i<idsInPlane.size(); ++i) std::cout << idsInPlane[i] << "  ";
      std::cout << std::endl;
    }






    
    std::vector<double> coplanarTimeAvg;
    std::vector<TVector3> coplanarLocAvg;

    int adj = -1;
    int numInPlane = 0;
    double timeAvg = 0;
    TVector3 locAvg(0.,0.,0.);
    for (size_t id1 = 0; id1 < ids.size(); ++id1) {
      numInPlane = 1;
      timeAvg = ticks[id1];
      locAvg = auxDetCenter(ids[id1]);
      std::vector<unsigned int> origIDs;
      origIDs.push_back(ids[id1]);
      for (size_t id2 = 0; id2 < id1; ++id2) {
	adj = adjacentCounter(ids[id1],ids[id2]);
	if (fVerbose) std::cout << "counter " << ids[id1] << " and " << ids[id2] 
				<< ", adj=" << adj << std::endl;
	if (!(adj > 0)) continue;
	++numInPlane;
	timeAvg += ticks[id2];
	locAvg += auxDetCenter(ids[id2]);
	origIDs.push_back(ids[id2]);
      }
      timeAvg *= (1./numInPlane);
      locAvg *= (1./numInPlane);
      coplanarTimeAvg.push_back(timeAvg);
      coplanarLocAvg.push_back(locAvg);
      if (fVerbose) {
	std::cout << "Avg Time = " << timeAvg << "  Avg Loc = (" << locAvg.X()
		  << "," << locAvg.Y() << "," << locAvg.Z() << ")" << std::endl;
	std::cout << "     for IDs...";
	for (size_t i = 0; i < origIDs.size(); ++i) std::cout << origIDs[i] << "  ";
	std::cout << std::endl;
      }
    }

    */
    


  t0v.clear();

//e.put(std::move(t0col));
}

/////////////////////////////////////////////////////////////////////////////////////

void lbne::T0Counter::beginJob()
{
  art::ServiceHandle<art::TFileService> tfs;

  if (fMakeTree) {
    fTree = tfs->make<TTree>("T0Counter","T0Counter");
    fTree->Branch("run",&run,"run/I");
    fTree->Branch("subrun",&subrun,"subrun/I");
    fTree->Branch("event",&event,"event/I");
    fTree->Branch("ntrigs",&ntrigs,"ntrigs/I");
    fTree->Branch("ntracks",&ntracks,"ntracks/I");
    fTree->Branch("auxdetid",&auxdetid,"auxdetid/I");
    fTree->Branch("tick",&tick,"tick/I");
  }
}

/////////////////////////////////////////////////////////////////////////////////////

void lbne::T0Counter::endJob()
{

}

/////////////////////////////////////////////////////////////////////////////////////

double lbne::T0Counter::tick2Time(unsigned int t)
{
  double time = (double)t+0.5;//get central value of tick bin
  time *= fSampleTimeCounter;//convert tick to time in ns
  time += fTriggerOffsetTPC;//adjust for possible TPC window offset
  time -= fCombinedTimeDelay;//correct for delay in signal propagation in cables and processing
  return time;
}

/////////////////////////////////////////////////////////////////////////////////////

TVector3 lbne::T0Counter::auxDetCenter(unsigned int c)
{
  try {
    const geo::AuxDetGeo & auxdet = fGeom->AuxDet(c);
    double center[3] = {0.,0.,0.};
    auxdet.GetCenter(center);
    return (TVector3)center;
  }
  catch ( cet::exception &e ) {
    mf::LogWarning("T0Counter::auxDetCenter") << e;
  }
  return TVector3(0.,0.,0.);
}

/////////////////////////////////////////////////////////////////////////////////////

TVector3 lbne::T0Counter::auxDetNormal(unsigned int c)
{
  try {
    const geo::AuxDetGeo &auxdet = fGeom->AuxDet(c);
    double normal[3] = {0.,0.,0.};
    double localnormal[3] = {0.,1.,0.};
    auxdet.LocalToWorldVect(localnormal,normal);
    return (TVector3)normal;
  }
  catch ( cet::exception &e ) {
    mf::LogWarning("T0Counter::auxDetNormal") << e;
  }
  return TVector3(0.,0.,0.);
}

/////////////////////////////////////////////////////////////////////////////////////

int lbne::T0Counter::adjacentCounter(unsigned int c1, unsigned int c2)
{ // return 0 for non-adjacent and non-coplanar
  // return 1 for non-adjacent and coplanar
  // return 2 for adjacent and (necessarily) coplanar
  // return 3 for identical counters
  // return -1 for error/exception
  if (c1 == c2) return 3;

  TVector3 direction = auxDetCenter(c1)-auxDetCenter(c2);
  double dot1 = std::abs(direction.Dot(auxDetNormal(c1)));
  double dot2 = std::abs(direction.Dot(auxDetNormal(c2)));

  if (dot1 > 1.e-6 && dot2 > 1.e-6) return 0;
  if (std::abs((int)c1-(int)c2) != 1) return 1;//change if AuxDetIDs get renumbered in a bad way
  else return 2;

  return -1;
}

DEFINE_ART_MODULE(lbne::T0Counter)
