////////////////////////////////////////////////////////////////////////
// Class:       SSPToOffline
// Module Type: producer
// File:        SSPToOffline_module.cc
//
// Repackage raw SSP data into OpDetPulse data products
//
// Alex Himmel ahimme@phy.duke.edu
//
////////////////////////////////////////////////////////////////////////

#include "art/Framework/Core/EDProducer.h"
#include "art/Framework/Core/ModuleMacros.h"
#include "art/Framework/Principal/Event.h"
#include "art/Framework/Principal/Handle.h"
#include "art/Framework/Principal/Run.h"
#include "art/Framework/Principal/SubRun.h"
#include "art/Utilities/InputTag.h"
#include "fhiclcpp/ParameterSet.h"
#include "messagefacility/MessageLogger/MessageLogger.h"

#include <memory>
#include <iostream>

//lbne-artdaq includes
#include "lbne-raw-data/Overlays/SSPFragment.hh"
#include "lbne-raw-data/Overlays/anlTypes.hh"
#include "artdaq-core/Data/Fragments.hh"

//larsoft includes
#include "RawData/raw.h"
#include "RawData/OpDetWaveform.h"
#include "Geometry/Geometry.h"

#include "utilities/UnpackFragment.h"

namespace DAQToOffline {
  class SSPToOffline;
}

class DAQToOffline::SSPToOffline : public art::EDProducer {
public:
    explicit SSPToOffline(fhicl::ParameterSet const & pset);
    // The destructor generated by the compiler is fine for classes
    // without bare pointers or other resource use.

    // Plugins should not be copied or assigned.
    SSPToOffline(SSPToOffline const &) = delete;
    SSPToOffline(SSPToOffline &&) = delete;
    SSPToOffline & operator = (SSPToOffline const &) = delete;
    SSPToOffline & operator = (SSPToOffline &&) = delete;
    void produce(art::Event & evt) override;
    void reconfigure(fhicl::ParameterSet const& pset);
    void printParameterSet();

private:

    std::string fFragType;
    std::string fRawDataLabel;
    std::string fOutputDataLabel;
    double      fNOvAClockFrequency; //MHz
    long        first_FirstSample;
    double      first_TimeStamp;
    long        first_InternalSample;
    double      first_InternalTimeStamp;
    //bool fDebug;
    //raw::Compress_t        fCompression;      ///< compression type to use
    //unsigned int           fZeroThreshold;    ///< Zero suppression threshold


};


DAQToOffline::SSPToOffline::SSPToOffline(fhicl::ParameterSet const & pset)
{

    this->reconfigure(pset);

    produces< std::vector<raw::OpDetWaveform> > (fOutputDataLabel);  

    first_FirstSample = -1;
    first_TimeStamp = -1;
}

void DAQToOffline::SSPToOffline::reconfigure(fhicl::ParameterSet const& pset){

    fFragType = pset.get<std::string>("FragType");
    fRawDataLabel = pset.get<std::string>("RawDataLabel");
    fOutputDataLabel = pset.get<std::string>("OutputDataLabel");
    fNOvAClockFrequency = pset.get<double>("NOvAClockFrequency"); // in MHz
    //fDebug = pset.get<bool>("Debug");

    //fZeroThreshold=0;
    //fCompression=raw::kNone;
    printParameterSet();

}

void DAQToOffline::SSPToOffline::printParameterSet(){

    mf::LogDebug("SSPToOffline") << "====================================" << "\n"
                                 << "Parameter Set" << "\n"
                                 << "====================================" << "\n"
                                 << "fFragType:        " << fFragType << "\n"
                                 << "fRawDataLabel:    " << fRawDataLabel << "\n"
                                 << "fOutputDataLabel: " << fOutputDataLabel << "\n"
                                 << "====================================" << "\n";
}

void DAQToOffline::SSPToOffline::produce(art::Event & evt)
{

    art::EventNumber_t eventNumber = evt.event();

    art::Handle<artdaq::Fragments> raw;
    evt.getByLabel(fRawDataLabel, fFragType, raw);

    // Check if there is SSP data in this event
    // Don't crash code if not present, just don't save anything
    try { raw->size(); }
    catch(std::exception e) {
      mf::LogWarning("SSPToOffline") << "WARNING: Raw SSP data not found in event " << eventNumber;
      return;
    }

    // Check that the data is valid
    if(!raw.isValid()){
        mf::LogError("SSPToOffline") << "Run: " << evt.run()
                  << ", SubRun: " << evt.subRun()
                  << ", Event: " << eventNumber
                  << " is NOT VALID";
        throw cet::exception("raw NOT VALID");
        return;
    }
  
    mf::LogDebug("SSPToOffline") << "Run: " << evt.run()
                                 << ", SubRun: " << evt.subRun()
                                 << ", Event: " << eventNumber
                                 << " has " << raw->size()
                                 << " rawFragments";

    std::unique_ptr< std::vector<raw::OpDetWaveform> > opDetWaveformVector(new std::vector <raw::OpDetWaveform>);

    for (size_t idx = 0; idx < raw->size(); ++idx) {
        const auto& frag((*raw)[idx]);

        lbne::SSPFragment sspf(frag);

        mf::LogDebug("SSPToOffline") << "\n"
                                     << "SSP fragment "     << frag.fragmentID() 
                                     << " has total size: " << sspf.hdr_event_size()
                                     << " and run number: " << sspf.hdr_run_number()
                                     << " with " << sspf.total_adc_values() << " total ADC values"
                                     << "\n"
                                     << "\n";

        const SSPDAQ::MillisliceHeader* meta=0;
        //get the information from the header
        if(frag.hasMetadata())
	{
            meta = &(frag.metadata<lbne::SSPFragment::Metadata>()->sliceHeader);
            
            mf::LogInfo("SSPToOffline")
                << "===Slice metadata====" << "\n"
                << "  Start time         " << meta->startTime << "\n"
                << "  End time           " << meta->endTime << "\n"
                << "  Packet length      " << meta->length << "\n"
                << "  Number of triggers " << meta->nTriggers << "\n"
                << "=====================";
	}
        else
        {
          mf::LogWarning("SSPToOffline") << "SSP fragment has no metadata associated with it.";
        }

      
        const unsigned int* dataPointer = sspf.dataBegin();

        
        unsigned int triggersProcessed=0;
        while((meta==0||triggersProcessed<meta->nTriggers)&&dataPointer<sspf.dataEnd()) {

            //
            // The elements of the OpDet Pulse
            //
            unsigned short     OpChannel = -1;     ///< channel in the readout
            unsigned long      FirstSample = 0;    ///< first sample time in ticks
            unsigned long      InternalSample = 0;    ///< first sample time in ticks
            double             TimeStamp = 0.0;    ///< first sample time in microseconds
            double             InternalTimeStamp = 0.0;
        

            
            const SSPDAQ::EventHeader* daqHeader=reinterpret_cast<const SSPDAQ::EventHeader*>(dataPointer);
            //get the information from the header
 
            uint32_t peaksum = ((daqHeader->group3 & 0x00FF) >> 16) + daqHeader->peakSumLow;
            if(peaksum & 0x00800000) {
                peaksum |= 0xFF000000;
            }

            // Extract values we need for the data product
            OpChannel = ((daqHeader->group2 & 0x000F) >> 0);
            
            FirstSample = ( ( (unsigned long)daqHeader->timestamp[3] << 48 )
                          + ( (unsigned long)daqHeader->timestamp[2] << 32 )
                          + ( (unsigned long)daqHeader->timestamp[1] << 16 )
                          + ( (unsigned long)daqHeader->timestamp[0] ) );

            InternalSample =  ( ((uint64_t)((uint64_t)daqHeader->intTimestamp[3] << 32))
                              + ((uint64_t)((uint64_t)daqHeader->intTimestamp[2]) << 16)
                              + ((uint64_t)((uint64_t)daqHeader->intTimestamp[1])) );

            TimeStamp = ((double)FirstSample)/fNOvAClockFrequency;
            InternalTimeStamp = ((double)InternalSample)/fNOvAClockFrequency;

            if (first_FirstSample < 0) {
              mf::LogInfo("SSPToOffline") << "Reset first time stamp to " << first_TimeStamp;
              first_FirstSample = FirstSample;
              first_TimeStamp = TimeStamp;
              first_InternalSample = InternalSample;
              first_InternalTimeStamp = InternalTimeStamp;
            }
            
            mf::LogDebug("SSPToOffline")
	    << "Header:                             " << daqHeader->header   << "\n"
	    << "Length:                             " << daqHeader->length   << "\n"
	    << "Trigger type:                       " << ((daqHeader->group1 & 0xFF00) >> 8) << "\n"
	    << "Status flags:                       " << ((daqHeader->group1 & 0x00F0) >> 4) << "\n"
	    << "Header type:                        " << ((daqHeader->group1 & 0x000F) >> 0) << "\n"
	    << "Trigger ID:                         " << daqHeader->triggerID << "\n"
	    << "Module ID:                          " << ((daqHeader->group2 & 0xFFF0) >> 4) << "\n"
	    << "Channel ID:                         " << ((daqHeader->group2 & 0x000F) >> 0) << "\n"
	    << "External (NOvA) timestamp:          " << FirstSample << " ticks" << "\n"
            << "                                    " << TimeStamp << " microseconds" << "\n"
	    << "Since first sample this run:        " << FirstSample-first_FirstSample << " ticks" << "\n"
            << "                                    " << TimeStamp-first_TimeStamp << " microseconds" << "\n"
	    << "Peak sum:                           " << peaksum << "\n"
	    << "Peak time:                          " << ((daqHeader->group3 & 0xFF00) >> 8) << "\n"
	    << "Prerise:                            " << ((daqHeader->group4 & 0x00FF) << 16) + daqHeader->preriseLow << "\n"
	    << "Integrated sum:                     " << ((unsigned int)(daqHeader->intSumHigh) << 8) + (((unsigned int)(daqHeader->group4) & 0xFF00) >> 8) << "\n"
	    << "Baseline:                           " << daqHeader->baseline << "\n"
	    << "CFD Timestamp interpolation points: " << daqHeader->cfdPoint[0] << " " << daqHeader->cfdPoint[1]
                                               << " " << daqHeader->cfdPoint[2] << " " << daqHeader->cfdPoint[3] << "\n"
	    << "Internal interpolation point:       " << daqHeader->intTimestamp[0] << "\n"
	    << "Internal timestamp:                 " << InternalSample << " ticks\n"
            << "                                    " << InternalTimeStamp << " microseconds" << "\n"
	    << "Relative internal timestamp:        " << InternalSample-first_InternalSample << " ticks" << "\n"
            << "                                    " << InternalTimeStamp-first_InternalTimeStamp << " microseconds"
            << ""  ;

            
            
            dataPointer+=sizeof(SSPDAQ::EventHeader)/sizeof(unsigned int);
 


            unsigned int nADC=(daqHeader->length-sizeof(SSPDAQ::EventHeader)/sizeof(unsigned int))*2;
            const unsigned short* adcPointer=reinterpret_cast<const unsigned short*>(dataPointer);

            // Initialize our 
            raw::OpDetWaveform Waveform(TimeStamp, OpChannel, nADC);


            for(size_t idata = 0; idata < nADC; idata++) {
                const unsigned short* adc = adcPointer + idata;
                Waveform.push_back(*adc);
            }
        

            opDetWaveformVector->emplace_back( std::move(Waveform) );
            dataPointer+=nADC/2;
            ++triggersProcessed;
        } // End of loop over triggers
    } // End of loop over fragments (raw)
    evt.put(std::move(opDetWaveformVector), fOutputDataLabel);


}

DEFINE_ART_MODULE(DAQToOffline::SSPToOffline)


